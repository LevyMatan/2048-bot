<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>2048 Bot — Play</title>
  <style>
    /* ───────── CSS Variables / Theming ───────── */
    :root {
      --bg: #faf8ef;
      --surface: #bbada0;
      --text: #776e65;
      --text-light: #f9f6f2;
      --accent: #8f7a66;
      --accent-hover: #7a6a5a;
      --btn-bg: #8f7a66;
      --btn-text: #f9f6f2;
      --btn-hover: #7a6a5a;
      --card-bg: #fff;
      --card-border: #e0d6cc;
      --cell-bg: rgba(238,228,218,0.35);
      --overlay: rgba(238,228,218,0.73);
      --shadow: 0 4px 20px rgba(0,0,0,0.08);
      --radius: 8px;
      --font: 'Segoe UI', system-ui, -apple-system, sans-serif;
      --mono: 'SF Mono', 'Fira Code', 'Cascadia Code', monospace;
    }
    @media (prefers-color-scheme: dark) {
      :root {
        --bg: #1a1a2e;
        --surface: #3d3552;
        --text: #e0d6f0;
        --text-light: #f0ecff;
        --accent: #7c6f9b;
        --accent-hover: #9b8fc0;
        --btn-bg: #5a4f7a;
        --btn-text: #f0ecff;
        --btn-hover: #7c6f9b;
        --card-bg: #252040;
        --card-border: #3d3552;
        --cell-bg: rgba(60,52,85,0.5);
        --overlay: rgba(26,26,46,0.8);
        --shadow: 0 4px 20px rgba(0,0,0,0.3);
      }
    }

    /* ───────── Reset & Base ───────── */
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
    html { font-size: 16px; }
    body {
      font-family: var(--font);
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 16px;
      overflow-x: hidden;
      -webkit-tap-highlight-color: transparent;
    }

    /* ───────── Header ───────── */
    .header {
      text-align: center;
      margin-bottom: 16px;
      width: 100%;
      max-width: 500px;
    }
    .header h1 {
      font-size: 2.4rem;
      font-weight: 800;
      letter-spacing: -1px;
      margin-bottom: 2px;
    }
    .header p {
      font-size: 0.85rem;
      opacity: 0.7;
    }
    .header p a {
      color: var(--accent);
      text-decoration: none;
    }
    .header p a:hover { text-decoration: underline; }

    /* ───────── Score Bar ───────── */
    .score-bar {
      display: flex;
      gap: 8px;
      justify-content: center;
      margin-bottom: 12px;
      width: 100%;
      max-width: 500px;
    }
    .score-card {
      flex: 1;
      background: var(--surface);
      color: var(--text-light);
      border-radius: var(--radius);
      padding: 8px 12px;
      text-align: center;
      min-width: 0;
    }
    .score-card .label {
      font-size: 0.65rem;
      text-transform: uppercase;
      letter-spacing: 1px;
      opacity: 0.8;
    }
    .score-card .value {
      font-size: 1.4rem;
      font-weight: 700;
      margin-top: 2px;
      white-space: nowrap;
    }

    /* ───────── Board Container ───────── */
    .board-wrapper {
      position: relative;
      width: 100%;
      max-width: 500px;
      aspect-ratio: 1;
      margin-bottom: 12px;
    }
    .board {
      width: 100%;
      height: 100%;
      background: var(--surface);
      border-radius: calc(var(--radius) + 4px);
      padding: 2.4%;
      display: grid;
      grid-template: repeat(4, 1fr) / repeat(4, 1fr);
      gap: 2.2%;
      position: relative;
      box-shadow: var(--shadow);
    }

    /* Grid background cells */
    .cell {
      background: var(--cell-bg);
      border-radius: var(--radius);
    }

    /* ───────── Tiles ───────── */
    .tile-layer {
      position: absolute;
      inset: 2.4%;
      pointer-events: none;
    }
    .tile {
      position: absolute;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      border-radius: var(--radius);
      transition: top 120ms ease-in-out, left 120ms ease-in-out;
      z-index: 1;
      user-select: none;
    }
    .tile.merged {
      z-index: 2;
      animation: pop 200ms ease 100ms;
    }
    .tile.new-tile {
      animation: appear 200ms ease;
    }
    @keyframes pop {
      0%   { transform: scale(1); }
      50%  { transform: scale(1.15); }
      100% { transform: scale(1); }
    }
    @keyframes appear {
      0%   { transform: scale(0); opacity: 0; }
      100% { transform: scale(1); opacity: 1; }
    }

    /* Tile colors */
    .tile-2    { background: #eee4da; color: #776e65; }
    .tile-4    { background: #ede0c8; color: #776e65; }
    .tile-8    { background: #f2b179; color: #f9f6f2; }
    .tile-16   { background: #f59563; color: #f9f6f2; }
    .tile-32   { background: #f67c5f; color: #f9f6f2; }
    .tile-64   { background: #f65e3b; color: #f9f6f2; }
    .tile-128  { background: #edcf72; color: #f9f6f2; font-size: 0.9em; }
    .tile-256  { background: #edcc61; color: #f9f6f2; font-size: 0.9em; }
    .tile-512  { background: #edc850; color: #f9f6f2; font-size: 0.9em; }
    .tile-1024 { background: #edc53f; color: #f9f6f2; font-size: 0.8em; }
    .tile-2048 { background: #edc22e; color: #f9f6f2; font-size: 0.8em; }
    .tile-4096 { background: #3c3a32; color: #f9f6f2; font-size: 0.75em; }
    .tile-8192 { background: #3c3a32; color: #f9f6f2; font-size: 0.75em; }
    .tile-super { background: #3c3a32; color: #f9f6f2; font-size: 0.65em; }

    @media (prefers-color-scheme: dark) {
      .tile-2    { background: #4a4268; color: #e0d6f0; }
      .tile-4    { background: #5a4f7a; color: #e0d6f0; }
      .tile-8    { background: #b07040; color: #f0ecff; }
      .tile-16   { background: #c06030; color: #f0ecff; }
      .tile-32   { background: #d04828; color: #f0ecff; }
      .tile-64   { background: #e03020; color: #f0ecff; }
      .tile-128  { background: #c0a030; color: #f0ecff; }
      .tile-256  { background: #c09820; color: #f0ecff; }
      .tile-512  { background: #c09010; color: #f0ecff; }
      .tile-1024 { background: #c08800; color: #f0ecff; }
      .tile-2048 { background: #d0a000; color: #f0ecff; }
      .tile-4096 { background: #2a2548; color: #f0ecff; }
      .tile-8192 { background: #2a2548; color: #f0ecff; }
      .tile-super { background: #1e1a38; color: #f0ecff; }
    }

    /* ───────── Game Over / Win Overlay ───────── */
    .overlay {
      position: absolute;
      inset: 0;
      background: var(--overlay);
      border-radius: calc(var(--radius) + 4px);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
      opacity: 0;
      pointer-events: none;
      transition: opacity 300ms;
    }
    .overlay.active {
      opacity: 1;
      pointer-events: auto;
    }
    .overlay h2 {
      font-size: 2rem;
      margin-bottom: 12px;
    }
    .overlay button {
      padding: 10px 28px;
      font-size: 1rem;
      font-weight: 600;
      border: none;
      border-radius: var(--radius);
      background: var(--btn-bg);
      color: var(--btn-text);
      cursor: pointer;
      transition: background 150ms;
    }
    .overlay button:hover { background: var(--btn-hover); }

    /* ───────── Controls ───────── */
    .controls {
      width: 100%;
      max-width: 500px;
      background: var(--card-bg);
      border: 1px solid var(--card-border);
      border-radius: var(--radius);
      padding: 14px;
      box-shadow: var(--shadow);
    }
    .controls-row {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
      margin-bottom: 10px;
    }
    .controls-row:last-child { margin-bottom: 0; }

    .controls label {
      font-size: 0.78rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      white-space: nowrap;
    }

    select, input[type="range"] {
      font-family: var(--font);
      font-size: 0.85rem;
    }
    select {
      padding: 6px 10px;
      border: 1px solid var(--card-border);
      border-radius: 6px;
      background: var(--bg);
      color: var(--text);
      cursor: pointer;
      outline: none;
    }
    select:focus { border-color: var(--accent); }

    .speed-control {
      display: flex;
      align-items: center;
      gap: 6px;
      flex: 1;
      min-width: 0;
    }
    .speed-control input[type="range"] {
      flex: 1;
      min-width: 60px;
      accent-color: var(--accent);
    }
    .speed-control .speed-label {
      font-size: 0.75rem;
      font-family: var(--mono);
      min-width: 40px;
      text-align: right;
    }

    .btn-group {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }
    .btn {
      padding: 7px 14px;
      font-size: 0.82rem;
      font-weight: 600;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      transition: background 150ms, transform 80ms;
      background: var(--btn-bg);
      color: var(--btn-text);
      white-space: nowrap;
    }
    .btn:hover { background: var(--btn-hover); }
    .btn:active { transform: scale(0.96); }
    .btn.secondary {
      background: var(--bg);
      color: var(--text);
      border: 1px solid var(--card-border);
    }
    .btn.secondary:hover { background: var(--card-border); }
    .btn.active {
      background: #4caf50;
      color: #fff;
    }
    .btn.active:hover { background: #43a047; }

    /* ───────── AI Status ───────── */
    .ai-status {
      text-align: center;
      font-size: 0.75rem;
      margin-top: 8px;
      opacity: 0.7;
      font-family: var(--mono);
      min-height: 1.2em;
    }

    /* ───────── TDL Weight Upload ───────── */
    .tdl-upload-row {
      display: none;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
      margin-bottom: 10px;
    }
    .tdl-upload-row.visible { display: flex; }
    .tdl-upload-row .file-btn {
      padding: 6px 12px;
      font-size: 0.8rem;
      font-weight: 600;
      border: 1px dashed var(--accent);
      border-radius: 6px;
      background: transparent;
      color: var(--accent);
      cursor: pointer;
      transition: background 150ms, border-style 150ms;
    }
    .tdl-upload-row .file-btn:hover {
      background: var(--accent);
      color: var(--btn-text);
      border-style: solid;
    }
    .tdl-upload-row .file-btn.loaded {
      background: #4caf50;
      color: #fff;
      border-color: #4caf50;
      border-style: solid;
    }
    .tdl-info {
      font-size: 0.72rem;
      opacity: 0.6;
      font-family: var(--mono);
    }
    .tdl-progress {
      width: 100%;
      height: 4px;
      background: var(--cell-bg);
      border-radius: 2px;
      overflow: hidden;
      display: none;
    }
    .tdl-progress.visible { display: block; }
    .tdl-progress-bar {
      height: 100%;
      background: var(--accent);
      border-radius: 2px;
      width: 0%;
      transition: width 200ms;
    }

    /* ───────── Teacher Panel ───────── */
    .teach-panel {
      width: 100%;
      max-width: 500px;
      margin-top: 12px;
      background: var(--card-bg);
      border: 1px solid var(--card-border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow: hidden;
      display: none;
    }
    .teach-panel.visible { display: block; }
    .teach-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 14px;
      border-bottom: 1px solid var(--card-border);
      cursor: pointer;
      user-select: none;
    }
    .teach-header h3 {
      font-size: 0.85rem;
      font-weight: 700;
    }
    .teach-header .tag {
      font-size: 0.65rem;
      font-weight: 600;
      padding: 2px 8px;
      border-radius: 99px;
      background: var(--accent);
      color: var(--btn-text);
    }
    .teach-body { padding: 12px 14px; }

    /* Explanation text */
    .teach-explain {
      font-size: 0.76rem;
      line-height: 1.6;
      margin-bottom: 12px;
      padding: 10px 12px;
      background: var(--bg);
      border-radius: 6px;
      border-left: 3px solid var(--accent);
    }
    .teach-explain code {
      font-family: var(--mono);
      font-size: 0.72rem;
      background: var(--card-border);
      padding: 1px 4px;
      border-radius: 3px;
    }
    .teach-formula {
      font-family: var(--mono);
      font-size: 0.78rem;
      text-align: center;
      padding: 8px;
      margin: 8px 0;
      background: var(--bg);
      border-radius: 6px;
      font-weight: 600;
      letter-spacing: 0.5px;
    }

    /* Move cards row */
    .teach-moves {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(105px, 1fr));
      gap: 8px;
      margin-bottom: 12px;
    }
    .teach-move {
      border: 2px solid var(--card-border);
      border-radius: var(--radius);
      padding: 8px;
      text-align: center;
      transition: border-color 200ms, box-shadow 200ms;
      position: relative;
    }
    .teach-move.best {
      border-color: #4caf50;
      box-shadow: 0 0 0 1px #4caf50, 0 2px 8px rgba(76,175,80,0.2);
    }
    .teach-move.invalid {
      opacity: 0.3;
      pointer-events: none;
    }
    .teach-move .dir-label {
      font-size: 0.7rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
    }
    .teach-move .dir-arrow {
      font-size: 1rem;
      line-height: 1;
    }
    .teach-move .best-badge {
      position: absolute;
      top: -6px;
      right: -6px;
      background: #4caf50;
      color: #fff;
      font-size: 0.6rem;
      font-weight: 700;
      padding: 2px 6px;
      border-radius: 99px;
      display: none;
    }
    .teach-move.best .best-badge { display: block; }

    /* Mini board inside move card */
    .mini-board {
      display: grid;
      grid-template: repeat(4, 1fr) / repeat(4, 1fr);
      gap: 2px;
      width: 76px;
      height: 76px;
      margin: 0 auto 8px;
      background: var(--surface);
      border-radius: 4px;
      padding: 3px;
    }
    .mini-cell {
      border-radius: 2px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.42rem;
      font-weight: 700;
      font-family: var(--mono);
      line-height: 1;
    }
    .mini-cell.empty { background: var(--cell-bg); }

    /* Value breakdown rows */
    .teach-vals {
      font-size: 0.7rem;
      font-family: var(--mono);
      text-align: left;
      line-height: 1.7;
    }
    .teach-vals .val-row {
      display: flex;
      justify-content: space-between;
    }
    .teach-vals .val-label { opacity: 0.7; }
    .teach-vals .val-num { font-weight: 700; }
    .teach-vals .val-total {
      border-top: 1px solid var(--card-border);
      margin-top: 2px;
      padding-top: 2px;
      font-weight: 700;
    }

    /* TDL per-pattern breakdown table */
    .teach-patterns-section { margin-top: 12px; }
    .teach-patterns-section h4 {
      font-size: 0.75rem;
      font-weight: 700;
      margin-bottom: 8px;
    }
    .pattern-breakdown {
      width: 100%;
      font-size: 0.7rem;
      font-family: var(--mono);
      border-collapse: collapse;
    }
    .pattern-breakdown th, .pattern-breakdown td {
      padding: 4px 6px;
      text-align: right;
      border-bottom: 1px solid var(--card-border);
    }
    .pattern-breakdown th {
      text-align: left;
      font-weight: 700;
      font-size: 0.65rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      opacity: 0.7;
    }
    .pattern-breakdown td:first-child {
      text-align: left;
      font-weight: 600;
    }
    .pattern-breakdown .row-total td {
      font-weight: 700;
      border-top: 2px solid var(--card-border);
    }

    /* Pattern position visualization */
    .teach-pattern-viz {
      margin-top: 12px;
    }
    .teach-pattern-viz h4 {
      font-size: 0.75rem;
      font-weight: 700;
      margin-bottom: 8px;
    }
    .teach-pattern-viz p {
      font-size: 0.7rem;
      opacity: 0.7;
      margin-top: 6px;
      line-height: 1.5;
    }
    .pattern-why {
      margin-top: 14px;
      font-size: 0.73rem;
      line-height: 1.7;
    }
    .pattern-why h5 {
      font-size: 0.75rem;
      font-weight: 700;
      margin: 12px 0 4px;
    }
    .pattern-why h5:first-child { margin-top: 0; }
    .pattern-why .why-point {
      display: flex;
      gap: 8px;
      margin-bottom: 6px;
      align-items: flex-start;
    }
    .pattern-why .why-icon {
      flex-shrink: 0;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.6rem;
      font-weight: 700;
      color: #fff;
      margin-top: 2px;
    }
    .pattern-why .why-text { flex: 1; }
    .pattern-why .why-text strong { font-weight: 700; }
    .pattern-why code {
      font-family: var(--mono);
      font-size: 0.68rem;
      background: var(--card-border);
      padding: 1px 4px;
      border-radius: 3px;
    }
    .shape-compare {
      display: flex;
      gap: 16px;
      flex-wrap: wrap;
      justify-content: center;
      margin: 10px 0;
    }
    .shape-item {
      text-align: center;
    }
    .shape-item .shape-label {
      font-size: 0.62rem;
      font-weight: 700;
      font-family: var(--mono);
      margin-bottom: 3px;
      opacity: 0.7;
    }
    .shape-grid {
      display: grid;
      grid-template: repeat(4, 14px) / repeat(4, 14px);
      gap: 1px;
      background: var(--surface);
      border-radius: 3px;
      padding: 2px;
    }
    .shape-grid .sg-on {
      background: var(--accent);
      border-radius: 2px;
    }
    .shape-grid .sg-off {
      background: var(--cell-bg);
      border-radius: 2px;
      opacity: 0.3;
    }
    .pattern-grids {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center;
    }
    .pattern-grid-item {
      text-align: center;
    }
    .pattern-grid-item .pg-label {
      font-size: 0.62rem;
      font-weight: 700;
      font-family: var(--mono);
      margin-bottom: 3px;
      opacity: 0.7;
    }
    .pattern-grid {
      display: grid;
      grid-template: repeat(4, 18px) / repeat(4, 18px);
      gap: 2px;
      background: var(--surface);
      border-radius: 4px;
      padding: 3px;
    }
    .pg-cell {
      border-radius: 2px;
      background: var(--cell-bg);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.5rem;
      font-weight: 700;
      font-family: var(--mono);
      color: #fff;
    }
    .pg-cell.pg-active { opacity: 1; }
    .pg-cell.pg-inactive { opacity: 0.2; }
    .pg-c0 { background: #e74c3c; }
    .pg-c1 { background: #3498db; }
    .pg-c2 { background: #2ecc71; }
    .pg-c3 { background: #f39c12; }

    /* Heuristic component bars */
    .heur-bars { margin-top: 4px; }
    .heur-bar-row {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 4px;
      font-size: 0.68rem;
      font-family: var(--mono);
    }
    .heur-bar-label {
      width: 100px;
      text-align: right;
      font-weight: 600;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .heur-bar {
      flex: 1;
      height: 14px;
      background: var(--cell-bg);
      border-radius: 3px;
      overflow: hidden;
      position: relative;
    }
    .heur-bar-fill {
      height: 100%;
      border-radius: 3px;
      transition: width 200ms;
    }
    .heur-bar-val {
      width: 60px;
      text-align: right;
      font-weight: 700;
      font-size: 0.65rem;
    }

    /* ───────── Step-by-step walkthrough ───────── */
    .teach-walkthrough { margin-top: 14px; }
    .teach-walkthrough h4 {
      font-size: 0.78rem;
      font-weight: 700;
      margin-bottom: 10px;
    }
    .walk-step {
      margin-bottom: 14px;
      padding-left: 28px;
      position: relative;
    }
    .walk-step::before {
      content: attr(data-step);
      position: absolute;
      left: 0;
      top: 0;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: var(--accent);
      color: var(--btn-text);
      font-size: 0.62rem;
      font-weight: 700;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .walk-step h5 {
      font-size: 0.74rem;
      font-weight: 700;
      margin-bottom: 4px;
    }
    .walk-step p, .walk-step .walk-detail {
      font-size: 0.7rem;
      line-height: 1.6;
    }
    .walk-step code {
      font-family: var(--mono);
      font-size: 0.66rem;
      background: var(--card-border);
      padding: 1px 4px;
      border-radius: 3px;
    }

    /* Symmetry lookup table */
    .sym-table {
      width: 100%;
      font-size: 0.62rem;
      font-family: var(--mono);
      border-collapse: collapse;
      margin: 8px 0;
    }
    .sym-table th, .sym-table td {
      padding: 3px 5px;
      border-bottom: 1px solid var(--card-border);
      text-align: right;
    }
    .sym-table th {
      text-align: left;
      font-weight: 700;
      font-size: 0.58rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      opacity: 0.7;
    }
    .sym-table td:first-child { text-align: left; }
    .sym-table .sym-identity td { background: rgba(var(--accent), 0.05); }
    .sym-total td {
      font-weight: 700;
      border-top: 2px solid var(--card-border);
    }

    /* Pipeline arrow */
    .walk-pipeline {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      flex-wrap: wrap;
      margin: 8px 0;
      font-family: var(--mono);
      font-size: 0.72rem;
      font-weight: 600;
    }
    .walk-pipeline .pipe-box {
      padding: 5px 10px;
      border-radius: 6px;
      background: var(--bg);
      border: 1px solid var(--card-border);
      text-align: center;
      line-height: 1.3;
    }
    .walk-pipeline .pipe-box.pipe-best {
      border-color: #4caf50;
      background: rgba(76,175,80,0.08);
    }
    .walk-pipeline .pipe-arrow {
      font-size: 1rem;
      opacity: 0.4;
    }
    .walk-pipeline .pipe-box small {
      display: block;
      font-size: 0.56rem;
      opacity: 0.6;
      font-weight: 400;
    }

    /* Tile highlight on board positions */
    .walk-pos-grid {
      display: inline-grid;
      grid-template: repeat(4, 16px) / repeat(4, 16px);
      gap: 1px;
      background: var(--surface);
      border-radius: 3px;
      padding: 2px;
      vertical-align: middle;
      margin: 4px 4px 4px 0;
    }
    .walk-pos-grid .wp-cell {
      border-radius: 2px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.45rem;
      font-weight: 700;
      font-family: var(--mono);
    }
    .walk-pos-grid .wp-active {
      background: var(--accent);
      color: var(--btn-text);
    }
    .walk-pos-grid .wp-inactive {
      background: var(--cell-bg);
      opacity: 0.2;
    }

    /* Collapse toggle */
    .walk-toggle {
      font-size: 0.68rem;
      color: var(--accent);
      cursor: pointer;
      font-weight: 600;
      user-select: none;
      margin-top: 4px;
      display: inline-block;
    }
    .walk-toggle:hover { text-decoration: underline; }
    .walk-collapsible { display: none; }
    .walk-collapsible.open { display: block; }

    /* ───────── Training Section ───────── */
    .train-section {
      margin-top: 16px;
      border-top: 2px solid var(--card-border);
      padding-top: 14px;
      display: none;
    }
    .train-section.visible { display: block; }
    .train-section h4 {
      font-size: 0.78rem;
      font-weight: 700;
      margin-bottom: 8px;
    }
    .train-controls {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
      margin-bottom: 10px;
    }
    .train-controls label {
      font-size: 0.7rem;
      font-weight: 600;
    }
    .train-controls input[type="number"] {
      width: 80px;
      padding: 4px 6px;
      font-size: 0.78rem;
      font-family: var(--mono);
      border: 1px solid var(--card-border);
      border-radius: 4px;
      background: var(--bg);
      color: var(--text);
    }
    .train-stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
      gap: 6px;
      margin: 10px 0;
    }
    .train-stat {
      background: var(--bg);
      border-radius: 6px;
      padding: 6px 10px;
      text-align: center;
    }
    .train-stat .ts-label {
      font-size: 0.58rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      opacity: 0.6;
      font-weight: 600;
    }
    .train-stat .ts-value {
      font-size: 1rem;
      font-weight: 700;
      font-family: var(--mono);
    }
    .train-progress-bar {
      width: 100%;
      height: 6px;
      background: var(--cell-bg);
      border-radius: 3px;
      overflow: hidden;
      margin: 8px 0;
    }
    .train-progress-bar .tpb-fill {
      height: 100%;
      background: var(--accent);
      border-radius: 3px;
      transition: width 300ms;
    }

    /* ── Backward pass replay ── */
    .bp-section {
      margin-top: 14px;
      border-top: 1px solid var(--card-border);
      padding-top: 12px;
    }
    .bp-section h5 {
      font-size: 0.75rem;
      font-weight: 700;
      margin-bottom: 4px;
    }
    .bp-section > p {
      font-size: 0.7rem;
      line-height: 1.6;
      margin-bottom: 10px;
    }
    .bp-section > p code {
      font-family: var(--mono);
      font-size: 0.66rem;
      background: var(--card-border);
      padding: 1px 4px;
      border-radius: 3px;
    }

    /* Game path timeline */
    .bp-timeline {
      display: flex;
      align-items: flex-start;
      gap: 0;
      overflow-x: auto;
      padding: 8px 0 12px;
      margin-bottom: 8px;
    }
    .bp-node {
      display: flex;
      flex-direction: column;
      align-items: center;
      min-width: 56px;
      position: relative;
    }
    .bp-node .bp-board {
      display: grid;
      grid-template: repeat(4, 10px) / repeat(4, 10px);
      gap: 1px;
      background: var(--surface);
      border-radius: 2px;
      padding: 1px;
      border: 2px solid transparent;
      transition: border-color 200ms;
    }
    .bp-node.bp-active .bp-board { border-color: var(--accent); }
    .bp-node.bp-prep .bp-board { border-color: #ff9800; }
    .bp-node .bp-board .bpc {
      border-radius: 1px;
      font-size: 0;
    }
    .bp-node .bp-reward {
      font-size: 0.52rem;
      font-family: var(--mono);
      margin-top: 2px;
      font-weight: 600;
    }
    .bp-node .bp-reward.zero { color: #ff9800; }
    .bp-arrow {
      display: flex;
      align-items: center;
      font-size: 0.6rem;
      opacity: 0.3;
      padding: 0 2px;
      margin-top: 14px;
    }

    /* Backward pass step detail */
    .bp-step-detail {
      background: var(--bg);
      border-radius: 6px;
      padding: 10px 12px;
      margin-bottom: 8px;
      font-size: 0.68rem;
      font-family: var(--mono);
      line-height: 1.8;
      border-left: 3px solid var(--accent);
    }
    .bp-step-detail.bp-prep-step {
      border-left-color: #ff9800;
      background: rgba(255, 152, 0, 0.05);
    }
    .bp-step-detail .bp-step-label {
      font-weight: 700;
      font-size: 0.72rem;
      margin-bottom: 4px;
      font-family: var(--font);
    }
    .bp-val-change {
      display: inline-block;
      padding: 1px 6px;
      border-radius: 3px;
      font-weight: 700;
    }
    .bp-val-up { background: rgba(76,175,80,0.15); color: #2e7d32; }
    .bp-val-down { background: rgba(244,67,54,0.15); color: #c62828; }
    @media (prefers-color-scheme: dark) {
      .bp-val-up { background: rgba(76,175,80,0.2); color: #81c784; }
      .bp-val-down { background: rgba(244,67,54,0.2); color: #ef9a9a; }
      .bp-step-detail.bp-prep-step { background: rgba(255,152,0,0.08); }
    }

    /* Prep move callout */
    .bp-prep-callout {
      background: rgba(255, 152, 0, 0.08);
      border: 1px solid rgba(255, 152, 0, 0.3);
      border-radius: 6px;
      padding: 10px 12px;
      margin-top: 12px;
      font-size: 0.72rem;
      line-height: 1.6;
    }
    .bp-prep-callout strong { color: #ff9800; }

    /* ───────── Keyboard Hints ───────── */
    .hints {
      margin-top: 12px;
      text-align: center;
      font-size: 0.72rem;
      opacity: 0.5;
      line-height: 1.6;
    }
    kbd {
      display: inline-block;
      padding: 2px 6px;
      font-family: var(--mono);
      font-size: 0.7rem;
      background: var(--card-bg);
      border: 1px solid var(--card-border);
      border-radius: 4px;
      box-shadow: 0 1px 0 var(--card-border);
    }

    /* ───────── Responsive ───────── */
    @media (max-width: 540px) {
      body { padding: 10px; }
      .header h1 { font-size: 1.8rem; }
      .score-card .value { font-size: 1.1rem; }
      .controls { padding: 10px; }
    }
  </style>
</head>
<body>

  <div class="header">
    <h1>2048 Bot</h1>
    <p>Play manually or watch AI strategies in action &middot; <a href="index.html">Documentation</a></p>
  </div>

  <div class="score-bar">
    <div class="score-card">
      <div class="label">Score</div>
      <div class="value" id="score">0</div>
    </div>
    <div class="score-card">
      <div class="label">Best</div>
      <div class="value" id="best-score">0</div>
    </div>
    <div class="score-card">
      <div class="label">Moves</div>
      <div class="value" id="moves">0</div>
    </div>
    <div class="score-card">
      <div class="label">Max Tile</div>
      <div class="value" id="max-tile">0</div>
    </div>
  </div>

  <div class="board-wrapper" id="board-wrapper">
    <div class="board" id="board">
      <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
      <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
      <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
      <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
      <div class="tile-layer" id="tile-layer"></div>
    </div>
    <div class="overlay" id="game-over-overlay">
      <h2 id="overlay-message">Game Over!</h2>
      <button onclick="game.restart()">Try Again</button>
    </div>
  </div>

  <div class="controls">
    <div class="controls-row">
      <label>Player:</label>
      <select id="player-select">
        <option value="human">Human (Keyboard / Swipe)</option>
        <option value="random">AI: Random</option>
        <option value="heuristic">AI: Heuristic</option>
        <option value="expectimax">AI: Expectimax (Depth 3)</option>
        <option value="expectimax-deep">AI: Expectimax (Depth 5)</option>
        <option value="tdl">AI: TDL (N-Tuple Network)</option>
      </select>
    </div>
    <div class="controls-row tdl-upload-row" id="tdl-upload-row">
      <input type="file" id="weights-file" accept=".bin" style="display:none">
      <button class="file-btn" id="btn-load-weights" onclick="document.getElementById('weights-file').click()">Load weights.bin</button>
      <span class="tdl-info" id="tdl-info">No weights loaded</span>
      <div class="tdl-progress" id="tdl-progress">
        <div class="tdl-progress-bar" id="tdl-progress-bar"></div>
      </div>
    </div>
    <div class="controls-row">
      <div class="speed-control">
        <label>Speed:</label>
        <input type="range" id="speed-slider" min="0" max="100" value="70">
        <span class="speed-label" id="speed-label">50ms</span>
      </div>
    </div>
    <div class="controls-row">
      <div class="btn-group">
        <button class="btn" id="btn-play" onclick="game.toggleAI()">&#9654; Play AI</button>
        <button class="btn secondary" id="btn-step" onclick="game.stepAI()">Step</button>
        <button class="btn secondary" onclick="game.restart()">New Game</button>
        <button class="btn secondary" onclick="game.undo()">Undo</button>
        <button class="btn secondary" id="btn-teacher" onclick="game.toggleTeacher()">Teacher</button>
      </div>
    </div>
    <div class="ai-status" id="ai-status"></div>
  </div>

  <div class="teach-panel" id="teach-panel">
    <div class="teach-header" onclick="game.toggleTeacher()">
      <h3>Move Analysis</h3>
      <span class="tag" id="teach-player-tag">—</span>
    </div>
    <div class="teach-body" id="teach-body">
      <div class="teach-explain" id="teach-explain"></div>
      <div class="teach-formula" id="teach-formula" style="display:none"></div>
      <div class="teach-moves" id="teach-moves"></div>
      <div class="teach-walkthrough" id="teach-walkthrough" style="display:none"></div>
      <div class="teach-patterns-section" id="teach-patterns-section" style="display:none">
        <h4>Per-Pattern Breakdown (best move afterstate)</h4>
        <table class="pattern-breakdown" id="pattern-table"></table>
      </div>
      <div class="teach-pattern-viz" id="teach-pattern-viz" style="display:none">
        <h4>N-Tuple Pattern Positions</h4>
        <div class="pattern-grids" id="pattern-grids"></div>
        <div id="pattern-explain"></div>
      </div>
      <div id="teach-heuristic-detail" style="display:none"></div>
      <div class="train-section" id="train-section">
        <h4>Train the Network</h4>
        <div class="teach-explain">
          The network learns by <strong>playing games against itself</strong> and updating weights via <strong>TD(0) (Temporal Difference)</strong>.
          After each game, it walks <em>backward</em> through every move and adjusts <code>V(s')</code> so it better predicts the future.
          This is how "preparation moves" (no immediate reward) learn to be valuable &mdash; the backward pass carries credit from future merges back to earlier states.
        </div>
        <div class="train-controls">
          <label>Games:</label>
          <input type="number" id="train-episodes" value="100" min="1" max="100000">
          <label>Alpha:</label>
          <input type="number" id="train-alpha" value="0.01" min="0.0001" max="1" step="0.001">
          <button class="btn" id="btn-train" onclick="game.startTraining()">Train</button>
          <button class="btn secondary" onclick="game.stopTraining()">Stop</button>
          <button class="btn secondary" onclick="game.resetNetwork()">Reset Weights</button>
          <button class="btn secondary" onclick="game.saveWeights()">Save weights.bin</button>
        </div>
        <div class="train-progress-bar"><div class="tpb-fill" id="train-pbar"></div></div>
        <div class="train-stats" id="train-stats"></div>
        <div class="bp-section" id="bp-section" style="display:none">
          <h5>Last Game: TD(0) Backward Pass</h5>
          <p>
            After the game ends, the network walks <strong>backward</strong> through every afterstate.
            At the terminal state, <code>V = 0</code> (game over, nothing left to gain).
            For each earlier step: <code>target = R<sub>next</sub> + V(s'<sub>next</sub>)</code>, then
            <code>error = target &minus; V(s')</code>, and weights are nudged: <code>V(s') += &alpha; &times; error</code>.
            <br>Moves with <strong style="color:#ff9800">R = 0</strong> (no merge) but positive updates are <strong style="color:#ff9800">preparation moves</strong> &mdash;
            the network learns they're valuable because they set up future merges.
          </p>
          <div id="bp-timeline-container"></div>
          <div id="bp-steps"></div>
          <div id="bp-prep-callout"></div>
        </div>
      </div>
    </div>
  </div>

  <div class="hints">
    <kbd>&uarr;</kbd> <kbd>&darr;</kbd> <kbd>&larr;</kbd> <kbd>&rarr;</kbd> or <kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd> to move
    &middot; <kbd>Space</kbd> play/pause AI &middot; <kbd>N</kbd> new game &middot; <kbd>Z</kbd> undo &middot; <kbd>T</kbd> teacher mode
  </div>

<script>
// ═══════════════════════════════════════════════════════════
//  2048 GAME ENGINE — Mirrors the C++ board representation
// ═══════════════════════════════════════════════════════════

const DIRECTIONS = { LEFT: 0, RIGHT: 1, UP: 2, DOWN: 3 };
const DIR_NAMES = ['Left', 'Right', 'Up', 'Down'];

/**
 * The board is a 4x4 grid stored as a flat array of 16 integers.
 * Each value is the log2 of the tile value (0 = empty, 1 = 2, 2 = 4, ...).
 * Index mapping: board[row * 4 + col]
 */
class Board2048 {
  constructor(grid) {
    // grid: flat array of 16 values (log2 representation)
    this.grid = grid ? grid.slice() : new Array(16).fill(0);
  }

  clone() {
    return new Board2048(this.grid);
  }

  getTile(row, col) {
    return this.grid[row * 4 + col];
  }

  setTile(row, col, val) {
    this.grid[row * 4 + col] = val;
  }

  /** Returns display value (2, 4, 8, ...) or 0 for empty */
  displayValue(row, col) {
    const v = this.getTile(row, col);
    return v === 0 ? 0 : (1 << v);
  }

  getEmptyTiles() {
    const empty = [];
    for (let i = 0; i < 16; i++) {
      if (this.grid[i] === 0) {
        empty.push({ row: Math.floor(i / 4), col: i % 4 });
      }
    }
    return empty;
  }

  getMaxTile() {
    let max = 0;
    for (let i = 0; i < 16; i++) {
      if (this.grid[i] > max) max = this.grid[i];
    }
    return max === 0 ? 0 : (1 << max);
  }

  addRandomTile() {
    const empty = this.getEmptyTiles();
    if (empty.length === 0) return null;
    const pos = empty[Math.floor(Math.random() * empty.length)];
    const val = Math.random() < 0.9 ? 1 : 2; // 90% -> 2, 10% -> 4
    this.setTile(pos.row, pos.col, val);
    return { row: pos.row, col: pos.col, val };
  }

  equals(other) {
    for (let i = 0; i < 16; i++) {
      if (this.grid[i] !== other.grid[i]) return false;
    }
    return true;
  }

  /**
   * Move the board in the given direction.
   * Returns { board, score, moved } where:
   *   board = new Board2048 after the move
   *   score = points earned from merges
   *   moved = whether the board changed
   */
  static move(board, direction) {
    const b = board.clone();
    let score = 0;
    let moved = false;

    // We always operate on rows left-to-right; rotate as needed
    const getLine = (b, i, dir) => {
      switch (dir) {
        case DIRECTIONS.LEFT:  return [b.getTile(i,0), b.getTile(i,1), b.getTile(i,2), b.getTile(i,3)];
        case DIRECTIONS.RIGHT: return [b.getTile(i,3), b.getTile(i,2), b.getTile(i,1), b.getTile(i,0)];
        case DIRECTIONS.UP:    return [b.getTile(0,i), b.getTile(1,i), b.getTile(2,i), b.getTile(3,i)];
        case DIRECTIONS.DOWN:  return [b.getTile(3,i), b.getTile(2,i), b.getTile(1,i), b.getTile(0,i)];
      }
    };

    const setLine = (b, i, dir, line) => {
      switch (dir) {
        case DIRECTIONS.LEFT:  b.setTile(i,0,line[0]); b.setTile(i,1,line[1]); b.setTile(i,2,line[2]); b.setTile(i,3,line[3]); break;
        case DIRECTIONS.RIGHT: b.setTile(i,3,line[0]); b.setTile(i,2,line[1]); b.setTile(i,1,line[2]); b.setTile(i,0,line[3]); break;
        case DIRECTIONS.UP:    b.setTile(0,i,line[0]); b.setTile(1,i,line[1]); b.setTile(2,i,line[2]); b.setTile(3,i,line[3]); break;
        case DIRECTIONS.DOWN:  b.setTile(3,i,line[0]); b.setTile(2,i,line[1]); b.setTile(1,i,line[2]); b.setTile(0,i,line[3]); break;
      }
    };

    for (let i = 0; i < 4; i++) {
      const line = getLine(b, i, direction);
      const original = line.slice();

      // Compact: slide non-zero tiles to the left
      const compacted = line.filter(v => v !== 0);
      while (compacted.length < 4) compacted.push(0);

      // Merge
      for (let j = 0; j < 3; j++) {
        if (compacted[j] !== 0 && compacted[j] === compacted[j + 1]) {
          compacted[j]++;
          score += (1 << compacted[j]); // merged tile value
          compacted[j + 1] = 0;
        }
      }

      // Compact again after merges
      const result = compacted.filter(v => v !== 0);
      while (result.length < 4) result.push(0);

      // Check if line changed
      for (let j = 0; j < 4; j++) {
        if (original[j] !== result[j]) moved = true;
      }

      setLine(b, i, direction, result);
    }

    return { board: b, score, moved };
  }

  /** Get all valid moves */
  static getValidMoves(board) {
    const moves = [];
    for (let dir = 0; dir < 4; dir++) {
      const result = Board2048.move(board, dir);
      if (result.moved) {
        moves.push({ direction: dir, board: result.board, score: result.score });
      }
    }
    return moves;
  }

  /** Check if the game is over */
  isGameOver() {
    return Board2048.getValidMoves(this).length === 0;
  }
}

// ═══════════════════════════════════════════════════════════
//  AI PLAYERS — Mirrors the C++ implementations
// ═══════════════════════════════════════════════════════════

const AI = {
  /** Random player: picks a random valid move */
  random(board) {
    const moves = Board2048.getValidMoves(board);
    if (moves.length === 0) return null;
    return moves[Math.floor(Math.random() * moves.length)];
  },

  /**
   * Heuristic evaluation functions (matching C++ evaluation.cpp)
   * Uses the "best" preset weights: emptyTiles: 427, monotonicity: 12,
   * smoothness: 29, cornerValue: 67, patternMatching: 186
   */
  _evalWeights: {
    emptyTiles: 427,
    monotonicity: 12,
    smoothness: 29,
    cornerValue: 67,
    patternMatching: 186,
  },

  _emptyTiles(grid) {
    let count = 0;
    for (let i = 0; i < 16; i++) if (grid[i] === 0) count++;
    return count;
  },

  _monotonicity(grid) {
    // Improved monotonicity from C++ (using log2 differences)
    const get = (r, c) => grid[r * 4 + c];
    const totals = [0, 0, 0, 0];

    for (let i = 0; i < 4; i++) {
      for (let j = 0; j < 3; j++) {
        if (get(i, j) > 0 && get(i, j + 1) > 0) {
          const current = Math.log2(get(i, j));
          const next = Math.log2(get(i, j + 1));
          if (current > next) totals[0] += current - next;
          else totals[1] += next - current;
        }
      }
    }

    for (let j = 0; j < 4; j++) {
      for (let i = 0; i < 3; i++) {
        if (get(i, j) > 0 && get(i + 1, j) > 0) {
          const current = Math.log2(get(i, j));
          const next = Math.log2(get(i + 1, j));
          if (current > next) totals[2] += current - next;
          else totals[3] += next - current;
        }
      }
    }

    return -(Math.min(totals[0], totals[1]) + Math.min(totals[2], totals[3]));
  },

  _smoothness(grid) {
    const get = (r, c) => grid[r * 4 + c];
    let score = 0, totalWeight = 0;

    for (let r = 0; r < 4; r++) {
      for (let c = 0; c < 4; c++) {
        if (get(r, c) === 0) continue;
        // Right neighbor
        if (c < 3 && get(r, c + 1) > 0) {
          const diff = Math.abs(get(r, c) - get(r, c + 1));
          const maxLog2 = Math.max(get(r, c), get(r, c + 1));
          const w = 1 << maxLog2;
          score += w * (1.0 / (1.0 + diff));
          totalWeight += w;
        }
        // Bottom neighbor
        if (r < 3 && get(r + 1, c) > 0) {
          const diff = Math.abs(get(r, c) - get(r + 1, c));
          const maxLog2 = Math.max(get(r, c), get(r + 1, c));
          const w = 1 << maxLog2;
          score += w * (1.0 / (1.0 + diff));
          totalWeight += w;
        }
      }
    }

    return totalWeight > 0 ? (score / totalWeight) * 1000 : 0;
  },

  _cornerValue(grid) {
    const get = (r, c) => grid[r * 4 + c];
    let maxTile = 0;
    for (let i = 0; i < 16; i++) if (grid[i] > maxTile) maxTile = grid[i];
    if (maxTile === 0) return 0;

    const corners = [[0,0],[0,3],[3,0],[3,3]];
    let score = 0;

    for (let r = 0; r < 4; r++) {
      for (let c = 0; c < 4; c++) {
        if (get(r, c) === 0) continue;
        let minDist = 6;
        for (const [cr, cc] of corners) {
          minDist = Math.min(minDist, Math.abs(r - cr) + Math.abs(c - cc));
        }
        const tileW = 1 << get(r, c);
        score += tileW * ((6 - minDist) / 6);
      }
    }

    const maxPossible = (1 << maxTile) * 4;
    return Math.min(1000, (score * 1000) / maxPossible);
  },

  _patternMatching(grid) {
    const snakeWeights = [
      [15, 14, 13, 12],
      [8, 9, 10, 11],
      [7, 6, 5, 4],
      [0, 1, 2, 3]
    ];
    const get = (r, c) => grid[r * 4 + c];
    let maxTile = 0;
    for (let i = 0; i < 16; i++) if (grid[i] > maxTile) maxTile = grid[i];

    let sumWeights = 0;
    for (let r = 0; r < 4; r++)
      for (let c = 0; c < 4; c++)
        sumWeights += snakeWeights[r][c];

    const maxScore = maxTile > 1 ? (1 << maxTile) * sumWeights : 2048;

    let score = 0;
    for (let r = 0; r < 4; r++) {
      for (let c = 0; c < 4; c++) {
        if (get(r, c) > 0) {
          score += (1 << get(r, c)) * snakeWeights[r][c];
        }
      }
    }

    return Math.min(1000, (score * 1000) / maxScore);
  },

  /** Composite evaluation using the "best" weights */
  evaluate(board) {
    const g = board.grid;
    const w = AI._evalWeights;
    return (
      AI._emptyTiles(g) * w.emptyTiles +
      AI._monotonicity(g) * w.monotonicity +
      AI._smoothness(g) * w.smoothness +
      AI._cornerValue(g) * w.cornerValue +
      AI._patternMatching(g) * w.patternMatching
    );
  },

  /** Heuristic player: evaluates all valid moves, picks the best */
  heuristic(board) {
    const moves = Board2048.getValidMoves(board);
    if (moves.length === 0) return null;

    let best = moves[0];
    let bestEval = AI.evaluate(moves[0].board);
    for (let i = 1; i < moves.length; i++) {
      const ev = AI.evaluate(moves[i].board);
      if (ev > bestEval) {
        bestEval = ev;
        best = moves[i];
      }
    }
    return best;
  },

  /**
   * Expectimax player (matching C++ expectimax_player.cpp)
   * With chance nodes for random tile placement
   */
  _expectimaxChance(board, depth, prob, evalFn) {
    if (depth <= 0 || prob < 0.001) {
      return evalFn(board);
    }

    const empty = board.getEmptyTiles();
    if (empty.length === 0) return evalFn(board);

    const perTileProb = prob / empty.length;
    let result = 0;

    for (const { row, col } of empty) {
      // 90% chance of 2 (val=1), 10% chance of 4 (val=2)
      const b2 = board.clone();
      b2.setTile(row, col, 1);
      const v2 = AI._expectimaxMax(b2, depth - 1, perTileProb * 0.9, evalFn) * 0.9;

      const b4 = board.clone();
      b4.setTile(row, col, 2);
      const v4 = AI._expectimaxMax(b4, depth - 1, perTileProb * 0.1, evalFn) * 0.1;

      result += v2 + v4;
    }

    return result / empty.length;
  },

  _expectimaxMax(board, depth, prob, evalFn) {
    if (depth <= 0) return evalFn(board);

    const moves = Board2048.getValidMoves(board);
    if (moves.length === 0) return evalFn(board);

    let best = -Infinity;
    for (const move of moves) {
      const value = AI._expectimaxChance(move.board, depth - 1, prob, evalFn);
      if (value > best) best = value;
    }
    return best;
  },

  expectimax(board, maxDepth = 3) {
    const moves = Board2048.getValidMoves(board);
    if (moves.length === 0) return null;

    const evalFn = (b) => AI.evaluate(b);
    let best = moves[0];
    let bestValue = -Infinity;

    for (const move of moves) {
      const value = AI._expectimaxChance(move.board, maxDepth, 1.0, evalFn);
      if (value > bestValue) {
        bestValue = value;
        best = move;
      }
    }
    return best;
  },
};

// ═══════════════════════════════════════════════════════════
//  N-TUPLE NETWORK — Mirrors ntuple_network.hpp
// ═══════════════════════════════════════════════════════════

/**
 * Board symmetry transformations operating on flat 16-element arrays.
 * Position layout:  0  1  2  3
 *                   4  5  6  7
 *                   8  9 10 11
 *                  12 13 14 15
 */
const NTuple = (() => {
  /** Transpose: (r,c) -> (c,r) */
  function transpose(arr) {
    const out = new Array(16);
    for (let r = 0; r < 4; r++)
      for (let c = 0; c < 4; c++)
        out[c * 4 + r] = arr[r * 4 + c];
    return out;
  }

  /** Mirror horizontally: (r,c) -> (r, 3-c) */
  function mirror(arr) {
    const out = new Array(16);
    for (let r = 0; r < 4; r++)
      for (let c = 0; c < 4; c++)
        out[r * 4 + c] = arr[r * 4 + (3 - c)];
    return out;
  }

  /** Rotate 90° clockwise = mirror(transpose(x)) */
  function rotateCW(arr) {
    return mirror(transpose(arr));
  }

  /**
   * Build the 8 symmetric index boards (matching C++ getSymmetricIndexBoards).
   * The index board has value i at position i.
   * Returns an array of 8 arrays, each of length 16.
   */
  function getSymmetricIndexBoards() {
    const identity = [];
    for (let i = 0; i < 16; i++) identity.push(i);

    const out = new Array(8);
    let b = identity;
    for (let i = 0; i < 4; i++) {
      out[i] = b;
      b = rotateCW(b);
    }
    b = mirror(identity);
    for (let i = 4; i < 8; i++) {
      out[i] = b;
      b = rotateCW(b);
    }
    return out;
  }

  const SYM_BOARDS = getSymmetricIndexBoards();

  /**
   * A single N-Tuple pattern with 8-way isomorphic lookups.
   * Mirrors NTuplePattern from ntuple_network.hpp.
   */
  class NTuplePattern {
    /**
     * @param {number[]} pattern - positions 0-15 to sample (e.g. [0,1,2,3,4,5])
     * @param {number} isoCount - number of isomorphic views (default 8)
     */
    constructor(pattern, isoCount = 8) {
      this.pattern = pattern;
      this.isoCount = isoCount;
      this.tableSize = Math.pow(16, pattern.length);

      // Weight table — Float32Array for memory efficiency
      this.weights = new Float32Array(this.tableSize);

      // Precompute isomorphic position mappings
      // isom[sym][j] = the position to read from the actual board
      // for pattern position j under symmetry sym
      this.isom = new Array(isoCount);
      for (let i = 0; i < isoCount; i++) {
        this.isom[i] = new Int32Array(pattern.length);
        for (let j = 0; j < pattern.length; j++) {
          this.isom[i][j] = SYM_BOARDS[i][pattern[j]];
        }
      }
    }

    /**
     * Compute lookup index from one isomorphic view.
     * Reads tile values from grid at the remapped positions.
     * @param {Int32Array} isomRow - remapped positions for this symmetry
     * @param {number[]} grid - flat 16-element array of log2 tile values
     * @returns {number} index into weight table
     */
    indexOf(isomRow, grid) {
      let index = 0;
      for (let i = 0; i < isomRow.length; i++) {
        index |= (grid[isomRow[i]] << (4 * i));
      }
      return index;
    }

    /**
     * Estimate board value: sum of weights over all isomorphic lookups.
     * @param {number[]} grid - flat 16-element grid
     * @returns {number}
     */
    estimate(grid) {
      let value = 0;
      for (let i = 0; i < this.isoCount; i++) {
        value += this.weights[this.indexOf(this.isom[i], grid)];
      }
      return value;
    }

    /**
     * Detailed per-symmetry breakdown for teacher mode.
     * Returns array of { symIndex, positions, tiles, index, weight }.
     */
    estimateDetailed(grid) {
      const details = [];
      for (let s = 0; s < this.isoCount; s++) {
        const positions = Array.from(this.isom[s]);
        const tiles = positions.map(p => grid[p]);
        const index = this.indexOf(this.isom[s], grid);
        const weight = this.weights[index];
        details.push({ symIndex: s, positions, tiles, index, weight });
      }
      return details;
    }

    /** TD update: add (adjust / isoCount) to each isomorphic lookup; return new sum. */
    update(grid, adjust) {
      let value = 0;
      const a = adjust / this.isoCount;
      for (let i = 0; i < this.isoCount; i++) {
        const idx = this.indexOf(this.isom[i], grid);
        this.weights[idx] += a;
        value += this.weights[idx];
      }
      return value;
    }
  }

  const SYM_NAMES = [
    'Identity', 'Rot 90\u00b0', 'Rot 180\u00b0', 'Rot 270\u00b0',
    'Mirror', 'Mirror+90\u00b0', 'Mirror+180\u00b0', 'Mirror+270\u00b0'
  ];

  /**
   * Network of N-Tuple patterns. Default: 4 six-tuples from the literature.
   * Mirrors NTupleNetwork from ntuple_network.hpp.
   */
  class NTupleNetwork {
    constructor() {
      this.patterns = [];
      this.loaded = false;
      this._addDefaultPatterns();
    }

    _addDefaultPatterns() {
      this.patterns = [
        new NTuplePattern([0, 1, 2, 3, 4, 5]),
        new NTuplePattern([4, 5, 6, 7, 8, 9]),
        new NTuplePattern([0, 1, 2, 4, 5, 6]),
        new NTuplePattern([4, 5, 6, 8, 9, 10]),
      ];
    }

    /**
     * Estimate board value by summing all pattern evaluations.
     * @param {number[]} grid - flat 16-element grid (log2 values)
     * @returns {number}
     */
    estimate(grid) {
      let value = 0;
      for (const p of this.patterns) {
        value += p.estimate(grid);
      }
      return value;
    }

    /** TD update: distribute adjust across patterns, return new value. */
    update(grid, adjust) {
      let value = 0;
      const a = adjust / this.patterns.length;
      for (const p of this.patterns) {
        value += p.update(grid, a);
      }
      return value;
    }

    /** Reset all weights to zero (for fresh training). */
    resetWeights() {
      for (const p of this.patterns) {
        p.weights.fill(0);
      }
      this.loaded = false;
    }

    /** Serialize weights to ArrayBuffer (same binary format as C++ save). */
    saveToBuffer() {
      // Calculate total size: 8 (numPatterns) + for each pattern: 8 (len) + len*4 (positions) + 16^len*4 (weights)
      let totalSize = 8; // numPatterns as size_t (8 bytes on 64-bit)
      for (const p of this.patterns) {
        const len = p.pattern.length;
        totalSize += 8;          // patternLength as size_t
        totalSize += len * 4;    // positions as int[]
        totalSize += p.weights.length * 4; // weights as float[]
      }

      const buffer = new ArrayBuffer(totalSize);
      const view = new DataView(buffer);
      let offset = 0;

      // Write numPatterns (size_t = 8 bytes, little-endian)
      view.setUint32(offset, this.patterns.length, true);
      view.setUint32(offset + 4, 0, true);
      offset += 8;

      for (const p of this.patterns) {
        const len = p.pattern.length;
        // Write patternLength (size_t = 8 bytes)
        view.setUint32(offset, len, true);
        view.setUint32(offset + 4, 0, true);
        offset += 8;

        // Write positions (int[])
        for (let i = 0; i < len; i++) {
          view.setInt32(offset, p.pattern[i], true);
          offset += 4;
        }

        // Write weights (float[])
        const weightBytes = new Uint8Array(buffer, offset, p.weights.length * 4);
        weightBytes.set(new Uint8Array(p.weights.buffer));
        offset += p.weights.length * 4;
      }

      return buffer;
    }

    /**
     * Load weights from an ArrayBuffer (binary format matching C++ save).
     *
     * Binary format (little-endian, compiled on 64-bit):
     *   8 bytes: size_t numPatterns
     *   For each pattern:
     *     8 bytes: size_t patternLength
     *     patternLength * 4 bytes: int[] positions (skipped)
     *     16^patternLength * 4 bytes: float[] weights
     *
     * @param {ArrayBuffer} buffer
     * @param {function} onProgress - callback(fraction) for progress
     * @returns {boolean} success
     */
    loadFromBuffer(buffer, onProgress) {
      const view = new DataView(buffer);
      let offset = 0;

      // Read number of patterns (size_t = 8 bytes on 64-bit)
      if (buffer.byteLength < 8) return false;

      // Read as two 32-bit values (little-endian)
      const numPatternsLow = view.getUint32(offset, true);
      const numPatternsHigh = view.getUint32(offset + 4, true);
      offset += 8;

      // Sanity check: numPatternsHigh should be 0 for reasonable counts
      if (numPatternsHigh !== 0 || numPatternsLow !== this.patterns.length) {
        console.error(`Expected ${this.patterns.length} patterns, got ${numPatternsLow} (high: ${numPatternsHigh})`);
        return false;
      }

      const numPatterns = numPatternsLow;

      for (let p = 0; p < numPatterns; p++) {
        // Read pattern length (size_t = 8 bytes)
        const lenLow = view.getUint32(offset, true);
        offset += 8; // skip full 8-byte size_t

        const expectedLen = this.patterns[p].pattern.length;
        if (lenLow !== expectedLen) {
          console.error(`Pattern ${p}: expected length ${expectedLen}, got ${lenLow}`);
          return false;
        }

        // Skip pattern positions (int[] = 4 bytes each)
        offset += lenLow * 4;

        // Read weights (float[] = 4 bytes each)
        const tableSize = this.patterns[p].tableSize;
        const weightBytes = tableSize * 4;

        if (offset + weightBytes > buffer.byteLength) {
          console.error(`Pattern ${p}: not enough data (need ${offset + weightBytes}, have ${buffer.byteLength})`);
          return false;
        }

        // Create Float32Array view directly from the buffer
        this.patterns[p].weights = new Float32Array(buffer, offset, tableSize);
        offset += weightBytes;

        if (onProgress) {
          onProgress((p + 1) / numPatterns);
        }
      }

      this.loaded = true;
      console.log(`Loaded ${numPatterns} patterns, ${(offset / 1024 / 1024).toFixed(1)} MB`);
      return true;
    }
  }

  return { NTupleNetwork, SYM_NAMES };
})();


// ═══════════════════════════════════════════════════════════
//  TDL PLAYER — Mirrors tdl_player.cpp
// ═══════════════════════════════════════════════════════════

/** Global N-Tuple network instance (shared across games) */
const tdlNetwork = new NTuple.NTupleNetwork();

/**
 * TDL player: for each valid move, compute (moveScore + network.estimate(afterstate))
 * and pick the move with the highest value.
 * This exactly mirrors TDLPlayer::chooseAction from tdl_player.cpp.
 */
AI.tdl = function(board) {
  if (!tdlNetwork.loaded) return null;

  const moves = Board2048.getValidMoves(board);
  if (moves.length === 0) return null;

  let best = moves[0];
  let bestVal = best.score + tdlNetwork.estimate(best.board.grid);

  for (let i = 1; i < moves.length; i++) {
    const m = moves[i];
    const val = m.score + tdlNetwork.estimate(m.board.grid);
    if (val > bestVal) {
      bestVal = val;
      best = m;
    }
  }
  return best;
};


// ═══════════════════════════════════════════════════════════
//  TRAINING ENGINE — TD(0) with backward pass recording
// ═══════════════════════════════════════════════════════════

const Trainer = {
  running: false,
  stats: { games: 0, totalScore: 0, maxScore: 0, maxTile: 0, tiles: {} },

  /** Play one full game, record the path, then do TD(0) backward update.
   *  Returns { path, backwardPass, score, maxTile } for visualization. */
  trainOneGame(network, alpha) {
    // — Forward pass: play the game, record afterstates + rewards —
    const game = new Board2048();
    game.addRandomTile();
    game.addRandomTile();

    const path = []; // { grid (afterstate), reward, moveDir }
    let totalScore = 0;

    for (;;) {
      const moves = Board2048.getValidMoves(game);
      if (moves.length === 0) break;

      // Choose best move: max(score + V(afterstate))
      let best = moves[0];
      let bestVal = best.score + network.estimate(best.board.grid);
      for (let i = 1; i < moves.length; i++) {
        const val = moves[i].score + network.estimate(moves[i].board.grid);
        if (val > bestVal) {
          bestVal = val;
          best = moves[i];
        }
      }

      totalScore += best.score;
      path.push({
        grid: best.board.grid.slice(),
        reward: best.score,
        moveDir: best.direction,
      });

      // Copy the afterstate into the game board, then add random tile
      for (let i = 0; i < 16; i++) game.grid[i] = best.board.grid[i];
      game.addRandomTile();
    }

    // — Backward pass: TD(0) weight updates —
    const backwardPass = []; // For visualization
    let target = 0; // Terminal state V = 0

    for (let i = path.length - 1; i >= 0; i--) {
      const afterstate = path[i].grid;
      const oldV = network.estimate(afterstate);
      const error = target - oldV;
      const newV = network.update(afterstate, alpha * error);
      const reward = path[i].reward;

      backwardPass.unshift({
        stepIndex: i,
        grid: afterstate,
        reward,
        moveDir: path[i].moveDir,
        oldV,
        target,
        error,
        newV,
        isPrep: (reward === 0 && error > 0),
      });

      target = reward + newV;
    }

    // Find max tile
    let maxTile = 0;
    for (let i = 0; i < 16; i++) {
      if (game.grid[i] > maxTile) maxTile = game.grid[i];
    }

    return { path, backwardPass, score: totalScore, maxTile };
  },

  /** Run training in async batches to keep UI responsive */
  async run(network, episodes, alpha, onProgress, onGameDone) {
    this.running = true;
    this.stats = { games: 0, totalScore: 0, maxScore: 0, maxTile: 0, tiles: {} };

    const BATCH_SIZE = 5; // games per animation frame
    let lastResult = null;

    for (let ep = 0; ep < episodes && this.running; ) {
      const batchEnd = Math.min(ep + BATCH_SIZE, episodes);
      for (; ep < batchEnd && this.running; ep++) {
        const result = this.trainOneGame(network, alpha);
        this.stats.games++;
        this.stats.totalScore += result.score;
        if (result.score > this.stats.maxScore) this.stats.maxScore = result.score;
        if (result.maxTile > this.stats.maxTile) this.stats.maxTile = result.maxTile;
        const tileName = (1 << result.maxTile);
        this.stats.tiles[tileName] = (this.stats.tiles[tileName] || 0) + 1;
        lastResult = result;
      }
      onProgress(ep, episodes, this.stats, lastResult);
      // Yield to the UI thread
      await new Promise(r => requestAnimationFrame(r));
    }

    this.running = false;
    if (onGameDone) onGameDone(lastResult);
    network.loaded = true; // Mark network as having weights
  },

  stop() { this.running = false; },
};


// ═══════════════════════════════════════════════════════════
//  BACKWARD PASS VISUALIZATION
// ═══════════════════════════════════════════════════════════

const BPViz = {
  DIR_ARROWS: ['\u2190', '\u2192', '\u2191', '\u2193'],

  TILE_COLORS: {
    0: ['var(--cell-bg)', 'transparent'],
    1: ['#eee4da', '#776e65'],
    2: ['#ede0c8', '#776e65'],
    3: ['#f2b179', '#f9f6f2'],
    4: ['#f59563', '#f9f6f2'],
    5: ['#f67c5f', '#f9f6f2'],
    6: ['#f65e3b', '#f9f6f2'],
    7: ['#edcf72', '#f9f6f2'],
    8: ['#edcc61', '#f9f6f2'],
    9: ['#edc850', '#f9f6f2'],
    10:['#edc53f', '#f9f6f2'],
    11:['#edc22e', '#f9f6f2'],
    12:['#3c3a32', '#f9f6f2'],
  },

  miniBoard(grid) {
    let h = '';
    for (let i = 0; i < 16; i++) {
      const v = grid[i];
      const c = this.TILE_COLORS[v] || this.TILE_COLORS[12];
      h += `<div class="bpc" style="background:${c[0]}"></div>`;
    }
    return h;
  },

  renderTimeline(backwardPass) {
    const container = document.getElementById('bp-timeline-container');
    if (!container) return;
    // Show last ~40 steps max for performance
    const steps = backwardPass.length > 40 ? backwardPass.slice(-40) : backwardPass;
    let h = '<div class="bp-timeline">';
    for (let i = 0; i < steps.length; i++) {
      const s = steps[i];
      const cls = s.isPrep ? 'bp-node bp-prep' : 'bp-node';
      const rewardCls = s.reward === 0 ? 'bp-reward zero' : 'bp-reward';
      h += `<div class="${cls}" title="Step ${s.stepIndex}: ${this.DIR_ARROWS[s.moveDir]}  R=${s.reward}">`;
      h += `<div class="bp-board">${this.miniBoard(s.grid)}</div>`;
      h += `<div class="${rewardCls}">R=${s.reward}</div>`;
      h += '</div>';
      if (i < steps.length - 1) h += '<div class="bp-arrow">\u2190</div>';
    }
    h += '</div>';
    if (backwardPass.length > 40) {
      h += `<div style="font-size:0.6rem; opacity:0.5; margin-top:-6px;">Showing last 40 of ${backwardPass.length} steps</div>`;
    }
    container.innerHTML = h;
  },

  renderSteps(backwardPass) {
    const container = document.getElementById('bp-steps');
    if (!container) return;

    // Show a few interesting steps: first, last, and preparation moves
    const interesting = [];
    const prepMoves = backwardPass.filter(s => s.isPrep);

    // Always show last step (terminal)
    if (backwardPass.length > 0) interesting.push(backwardPass[backwardPass.length - 1]);

    // Show up to 3 prep moves
    for (let i = 0; i < Math.min(3, prepMoves.length); i++) {
      if (!interesting.includes(prepMoves[i])) interesting.push(prepMoves[i]);
    }

    // Show first step
    if (backwardPass.length > 0 && !interesting.includes(backwardPass[0])) {
      interesting.push(backwardPass[0]);
    }

    // Sort by stepIndex
    interesting.sort((a, b) => a.stepIndex - b.stepIndex);

    let h = '';
    for (const s of interesting) {
      const cls = s.isPrep ? 'bp-step-detail bp-prep-step' : 'bp-step-detail';
      const label = s.isPrep ? `Step ${s.stepIndex} ${this.DIR_ARROWS[s.moveDir]} (Preparation Move)` :
                    s.stepIndex === backwardPass.length - 1 ? `Step ${s.stepIndex} ${this.DIR_ARROWS[s.moveDir]} (Last Move)` :
                    `Step ${s.stepIndex} ${this.DIR_ARROWS[s.moveDir]}`;
      const delta = s.newV - s.oldV;
      const deltaCls = delta > 0 ? 'bp-val-change bp-val-up' : delta < 0 ? 'bp-val-change bp-val-down' : 'bp-val-change';
      const sign = delta >= 0 ? '+' : '';

      h += `<div class="${cls}">`;
      h += `<div class="bp-step-label">${label}</div>`;
      h += `target = R<sub>next</sub> + V(s'<sub>next</sub>) = <strong>${s.target.toFixed(1)}</strong><br>`;
      h += `old V(s') = <strong>${s.oldV.toFixed(1)}</strong><br>`;
      h += `error = ${s.target.toFixed(1)} &minus; ${s.oldV.toFixed(1)} = <strong>${s.error.toFixed(2)}</strong><br>`;
      h += `new V(s') = ${s.oldV.toFixed(1)} + &alpha;&times;${s.error.toFixed(2)} = <strong>${s.newV.toFixed(1)}</strong> `;
      h += `<span class="${deltaCls}">${sign}${delta.toFixed(2)}</span>`;
      if (s.isPrep) {
        h += `<br><em style="color:#ff9800; font-size:0.62rem">` +
             `Reward was 0 (no merge), but V increased because future steps had high rewards.</em>`;
      }
      h += '</div>';
    }

    if (backwardPass.length > interesting.length) {
      h += `<div style="font-size:0.6rem; opacity:0.5; margin-top:4px;">` +
           `Showing ${interesting.length} of ${backwardPass.length} steps ` +
           `(${prepMoves.length} preparation moves in total)</div>`;
    }

    container.innerHTML = h;
  },

  renderPrepCallout(backwardPass) {
    const container = document.getElementById('bp-prep-callout');
    if (!container) return;

    const prepMoves = backwardPass.filter(s => s.isPrep);
    const totalSteps = backwardPass.length;
    const pct = totalSteps > 0 ? (prepMoves.length / totalSteps * 100).toFixed(0) : 0;

    if (prepMoves.length === 0) {
      container.innerHTML = '<div class="bp-prep-callout">' +
        '<strong>No preparation moves</strong> in this game. ' +
        'Every move produced immediate reward (merged tiles). ' +
        'Try training more games to see examples where the network makes strategic no-merge moves.' +
        '</div>';
      return;
    }

    const avgDelta = prepMoves.reduce((s, m) => s + (m.newV - m.oldV), 0) / prepMoves.length;

    container.innerHTML = '<div class="bp-prep-callout">' +
      `<strong>Preparation Moves: ${prepMoves.length} of ${totalSteps} steps (${pct}%)</strong><br>` +
      `These moves didn't merge any tiles (R = 0), yet the backward pass <em>increased</em> their value ` +
      `by an average of <strong>${avgDelta.toFixed(2)}</strong>. ` +
      `Why? Because the moves that followed them produced high rewards. ` +
      `TD(0) carries that credit backward: the network learns that the board layouts ` +
      `produced by these "preparation" moves are <em>intrinsically valuable</em> &mdash; ` +
      `they set up the big merges that come later. ` +
      `Over thousands of games, the network builds an intuition for which board shapes ` +
      `are worth pursuing, even when no immediate points are scored.` +
      '</div>';
  },

  render(backwardPass) {
    if (!backwardPass || backwardPass.length === 0) return;
    this.renderTimeline(backwardPass);
    this.renderSteps(backwardPass);
    this.renderPrepCallout(backwardPass);
  },
};


// ═══════════════════════════════════════════════════════════
//  TEACHER MODE — Analysis Engine
// ═══════════════════════════════════════════════════════════

const Teacher = {
  DIR_ARROWS: ['\u2190', '\u2192', '\u2191', '\u2193'], // ← → ↑ ↓

  TILE_COLORS: {
    0: ['var(--cell-bg)', 'transparent'],
    1: ['#eee4da', '#776e65'],   // 2
    2: ['#ede0c8', '#776e65'],   // 4
    3: ['#f2b179', '#f9f6f2'],   // 8
    4: ['#f59563', '#f9f6f2'],   // 16
    5: ['#f67c5f', '#f9f6f2'],   // 32
    6: ['#f65e3b', '#f9f6f2'],   // 64
    7: ['#edcf72', '#f9f6f2'],   // 128
    8: ['#edcc61', '#f9f6f2'],   // 256
    9: ['#edc850', '#f9f6f2'],   // 512
    10: ['#edc53f', '#f9f6f2'],  // 1024
    11: ['#edc22e', '#f9f6f2'],  // 2048
    12: ['#3c3a32', '#f9f6f2'],  // 4096+
  },

  PATTERN_COLORS: ['#e74c3c', '#3498db', '#2ecc71', '#f39c12'],

  HEUR_COLORS: {
    emptyTiles: '#3498db',
    monotonicity: '#e74c3c',
    smoothness: '#2ecc71',
    cornerValue: '#f39c12',
    patternMatching: '#9b59b6',
  },

  /** Get tile background + text color for a log2 value */
  tileStyle(log2val) {
    const key = log2val > 12 ? 12 : log2val;
    return Teacher.TILE_COLORS[key] || Teacher.TILE_COLORS[12];
  },

  /** Build a mini board HTML for a given Board2048 */
  miniBoard(board) {
    let html = '<div class="mini-board">';
    for (let r = 0; r < 4; r++) {
      for (let c = 0; c < 4; c++) {
        const v = board.getTile(r, c);
        if (v === 0) {
          html += '<div class="mini-cell empty"></div>';
        } else {
          const [bg, fg] = Teacher.tileStyle(v);
          const display = (1 << v);
          html += `<div class="mini-cell" style="background:${bg};color:${fg}">${display}</div>`;
        }
      }
    }
    html += '</div>';
    return html;
  },

  /** Format a number nicely */
  fmt(n, decimals = 0) {
    if (Math.abs(n) >= 1e6) return (n / 1e6).toFixed(1) + 'M';
    if (Math.abs(n) >= 1e4) return (n / 1e3).toFixed(1) + 'K';
    return decimals > 0 ? n.toFixed(decimals) : Math.round(n).toLocaleString();
  },

  /** Analyze moves for TDL player */
  analyzeTDL(board) {
    const allDirs = [0, 1, 2, 3];
    const results = allDirs.map(dir => {
      const r = Board2048.move(board, dir);
      if (!r.moved) return { dir, valid: false };

      const afterGrid = r.board.grid;
      const networkVal = tdlNetwork.estimate(afterGrid);
      const perPattern = tdlNetwork.patterns.map((p, idx) => ({
        index: idx,
        positions: p.pattern,
        value: p.estimate(afterGrid),
        detailed: p.estimateDetailed(afterGrid),
      }));

      return {
        dir,
        valid: true,
        afterstate: r.board,
        moveScore: r.score,
        networkVal,
        total: r.score + networkVal,
        perPattern,
      };
    });

    // Find best
    let bestIdx = -1, bestTotal = -Infinity;
    for (let i = 0; i < results.length; i++) {
      if (results[i].valid && results[i].total > bestTotal) {
        bestTotal = results[i].total;
        bestIdx = i;
      }
    }
    if (bestIdx >= 0) results[bestIdx].isBest = true;

    return { type: 'tdl', results, bestIdx };
  },

  /** Analyze moves for Heuristic player */
  analyzeHeuristic(board) {
    const w = AI._evalWeights;
    const componentNames = ['emptyTiles', 'monotonicity', 'smoothness', 'cornerValue', 'patternMatching'];
    const evalFns = {
      emptyTiles: AI._emptyTiles,
      monotonicity: AI._monotonicity,
      smoothness: AI._smoothness,
      cornerValue: AI._cornerValue,
      patternMatching: AI._patternMatching,
    };

    const allDirs = [0, 1, 2, 3];
    const results = allDirs.map(dir => {
      const r = Board2048.move(board, dir);
      if (!r.moved) return { dir, valid: false };

      const g = r.board.grid;
      const components = componentNames.map(name => ({
        name,
        raw: evalFns[name](g),
        weight: w[name],
        weighted: evalFns[name](g) * w[name],
      }));
      const total = components.reduce((s, c) => s + c.weighted, 0);

      return { dir, valid: true, afterstate: r.board, components, total };
    });

    let bestIdx = -1, bestTotal = -Infinity;
    for (let i = 0; i < results.length; i++) {
      if (results[i].valid && results[i].total > bestTotal) {
        bestTotal = results[i].total;
        bestIdx = i;
      }
    }
    if (bestIdx >= 0) results[bestIdx].isBest = true;

    return { type: 'heuristic', results, bestIdx };
  },

  /** Analyze moves for Expectimax player */
  analyzeExpectimax(board, depth) {
    const evalFn = (b) => AI.evaluate(b);
    const allDirs = [0, 1, 2, 3];
    const results = allDirs.map(dir => {
      const r = Board2048.move(board, dir);
      if (!r.moved) return { dir, valid: false };

      const t0 = performance.now();
      const expectedVal = AI._expectimaxChance(r.board, depth, 1.0, evalFn);
      const elapsed = performance.now() - t0;

      return { dir, valid: true, afterstate: r.board, moveScore: r.score, expectedVal, total: expectedVal, elapsed };
    });

    let bestIdx = -1, bestTotal = -Infinity;
    for (let i = 0; i < results.length; i++) {
      if (results[i].valid && results[i].total > bestTotal) {
        bestTotal = results[i].total;
        bestIdx = i;
      }
    }
    if (bestIdx >= 0) results[bestIdx].isBest = true;

    return { type: 'expectimax', results, bestIdx, depth };
  },

  /** Analyze for Random player */
  analyzeRandom(board) {
    const allDirs = [0, 1, 2, 3];
    const results = allDirs.map(dir => {
      const r = Board2048.move(board, dir);
      if (!r.moved) return { dir, valid: false };
      return { dir, valid: true, afterstate: r.board, moveScore: r.score };
    });
    const validCount = results.filter(r => r.valid).length;
    results.forEach(r => { if (r.valid) r.probability = (100 / validCount).toFixed(0) + '%'; });
    return { type: 'random', results, validCount };
  },

  // ── Rendering ──

  renderMoveCards(analysis) {
    const container = document.getElementById('teach-moves');
    let html = '';
    const results = analysis.results;

    for (const r of results) {
      const cls = !r.valid ? 'teach-move invalid' : (r.isBest ? 'teach-move best' : 'teach-move');
      html += `<div class="${cls}">`;
      html += `<span class="best-badge">BEST</span>`;
      html += `<div class="dir-label"><span class="dir-arrow">${Teacher.DIR_ARROWS[r.dir]}</span> ${DIR_NAMES[r.dir]}</div>`;

      if (!r.valid) {
        html += '<div style="font-size:0.65rem;opacity:0.5;padding:20px 0">Invalid</div>';
      } else {
        html += Teacher.miniBoard(r.afterstate);
        html += '<div class="teach-vals">';

        if (analysis.type === 'tdl') {
          html += `<div class="val-row"><span class="val-label">R(s,a)</span><span class="val-num">+${Teacher.fmt(r.moveScore)}</span></div>`;
          html += `<div class="val-row"><span class="val-label">V(s')</span><span class="val-num">${Teacher.fmt(r.networkVal, 1)}</span></div>`;
          html += `<div class="val-row val-total"><span class="val-label">Total</span><span class="val-num">${Teacher.fmt(r.total, 1)}</span></div>`;
        } else if (analysis.type === 'heuristic') {
          html += `<div class="val-row val-total"><span class="val-label">Eval</span><span class="val-num">${Teacher.fmt(r.total, 1)}</span></div>`;
        } else if (analysis.type === 'expectimax') {
          html += `<div class="val-row"><span class="val-label">E[V]</span><span class="val-num">${Teacher.fmt(r.total, 1)}</span></div>`;
          html += `<div class="val-row"><span class="val-label">Time</span><span class="val-num">${r.elapsed.toFixed(0)}ms</span></div>`;
        } else if (analysis.type === 'random') {
          html += `<div class="val-row"><span class="val-label">P(pick)</span><span class="val-num">${r.probability}</span></div>`;
          html += `<div class="val-row"><span class="val-label">Score</span><span class="val-num">+${Teacher.fmt(r.moveScore)}</span></div>`;
        }

        html += '</div>';
      }

      html += '</div>';
    }

    container.innerHTML = html;
  },

  renderTDLPatternBreakdown(analysis) {
    const section = document.getElementById('teach-patterns-section');
    const table = document.getElementById('pattern-table');

    const bestResult = analysis.results[analysis.bestIdx];
    if (!bestResult || !bestResult.perPattern) {
      section.style.display = 'none';
      return;
    }

    section.style.display = 'block';

    let html = '<tr><th>Pattern</th><th>Positions</th><th>V contrib.</th></tr>';
    let totalV = 0;
    for (const pp of bestResult.perPattern) {
      const posStr = '[' + pp.positions.join(',') + ']';
      html += `<tr>
        <td><span style="display:inline-block;width:8px;height:8px;border-radius:50%;background:${Teacher.PATTERN_COLORS[pp.index]};margin-right:4px"></span>P${pp.index + 1}</td>
        <td style="font-size:0.62rem;opacity:0.7">${posStr}</td>
        <td>${Teacher.fmt(pp.value, 1)}</td>
      </tr>`;
      totalV += pp.value;
    }
    html += `<tr class="row-total">
      <td>Total V(s')</td>
      <td></td>
      <td>${Teacher.fmt(totalV, 1)}</td>
    </tr>`;

    table.innerHTML = html;
  },

  renderPatternViz() {
    const viz = document.getElementById('teach-pattern-viz');
    const grids = document.getElementById('pattern-grids');
    const explain = document.getElementById('pattern-explain');
    viz.style.display = 'block';

    // ── Pattern grids ──
    const patterns = [[0,1,2,3,4,5],[4,5,6,7,8,9],[0,1,2,4,5,6],[4,5,6,8,9,10]];
    let html = '';

    patterns.forEach((pat, pIdx) => {
      const posSet = new Set(pat);
      html += '<div class="pattern-grid-item">';
      html += `<div class="pg-label" style="color:${Teacher.PATTERN_COLORS[pIdx]}">P${pIdx + 1}</div>`;
      html += '<div class="pattern-grid">';
      for (let pos = 0; pos < 16; pos++) {
        const active = posSet.has(pos);
        const cls = active ? `pg-cell pg-active pg-c${pIdx}` : 'pg-cell pg-inactive';
        const label = active ? pos : '';
        html += `<div class="${cls}">${label}</div>`;
      }
      html += '</div></div>';
    });

    grids.innerHTML = html;

    // ── Shape comparison: show the two distinct shapes ──
    const shape1 = [0,1,2,3,4,5]; // row+2
    const shape2 = [0,1,2,4,5,6]; // 2×3 rect
    function miniShapeGrid(positions, color) {
      const s = new Set(positions);
      let h = '<div class="shape-grid">';
      for (let i = 0; i < 16; i++) {
        h += `<div class="${s.has(i) ? 'sg-on' : 'sg-off'}" ${s.has(i) ? 'style="background:'+color+'"' : ''}></div>`;
      }
      return h + '</div>';
    }

    // ── Full explanation ──
    let ex = '<div class="pattern-why">';

    ex += '<h5>Why these specific patterns?</h5>';

    // Point 1: Two distinct shapes
    ex += '<div class="why-point">';
    ex += `<span class="why-icon" style="background:#3498db">1</span>`;
    ex += `<div class="why-text"><strong>Two distinct shapes for shape diversity.</strong> The 4 patterns use only two base shapes, each shifted down one row to create a pair:</div>`;
    ex += '</div>';

    ex += '<div class="shape-compare">';
    ex += '<div class="shape-item">';
    ex += '<div class="shape-label">Shape A: "Row + 2"</div>';
    ex += miniShapeGrid(shape1, '#e74c3c');
    ex += '<div class="shape-label" style="margin-top:3px">P1, P2</div>';
    ex += '</div>';
    ex += '<div class="shape-item">';
    ex += '<div class="shape-label">Shape B: "2\u00d73 Rectangle"</div>';
    ex += miniShapeGrid(shape2, '#2ecc71');
    ex += '<div class="shape-label" style="margin-top:3px">P3, P4</div>';
    ex += '</div>';
    ex += '</div>';

    // Point 2: Contiguity / Locality
    ex += '<div class="why-point">';
    ex += `<span class="why-icon" style="background:#e74c3c">2</span>`;
    ex += `<div class="why-text"><strong>Contiguous positions capture local structure.</strong> In 2048, tiles merge with their neighbors. All pattern positions are adjacent on the board, so each tuple captures relationships between tiles that directly interact &mdash; exactly the information needed to recognize good (or bad) tile configurations.</div>`;
    ex += '</div>';

    // Point 3: Shape A rationale
    ex += '<div class="why-point">';
    ex += `<span class="why-icon" style="background:#f39c12">3</span>`;
    ex += `<div class="why-text"><strong>Shape A (row + 2) captures horizontal flow.</strong> A full row of 4 tiles detects merging chains like <code>[2,2,4,8]</code> and whether the row is monotonically increasing/decreasing. The 2 cells below link it to vertical structure, detecting L-shaped patterns and corner formations that are critical for high scores.</div>`;
    ex += '</div>';

    // Point 4: Shape B rationale
    ex += '<div class="why-point">';
    ex += `<span class="why-icon" style="background:#2ecc71">4</span>`;
    ex += `<div class="why-text"><strong>Shape B (2\u00d73 rectangle) captures 2D local neighborhoods.</strong> This compact rectangle sees a dense patch of the board simultaneously, detecting spatial patterns like "high tile in corner with descending neighbors" or "two rows ready to merge together". It complements Shape A by being wider vertically (2 rows) but narrower horizontally (3 cols).</div>`;
    ex += '</div>';

    // Point 5: Vertical translation
    ex += '<div class="why-point">';
    ex += `<span class="why-icon" style="background:#9b59b6">5</span>`;
    ex += `<div class="why-text"><strong>Each shape is used twice, shifted down by one row.</strong> P1 and P2 are the same shape in rows 0\u20131 and rows 1\u20132. P3 and P4 are the same shape in rows 0\u20131 and rows 1\u20132. The overlap at row 1 means positions 4\u20135 are seen by <em>all four</em> patterns, giving the network extra sensitivity to the middle of the board where the action often is.</div>`;
    ex += '</div>';

    // Point 6: Symmetry
    ex += '<div class="why-point">';
    ex += `<span class="why-icon" style="background:#1abc9c">6</span>`;
    ex += `<div class="why-text"><strong>8-fold symmetry covers the entire board from just the top-left corner.</strong> Every base pattern sits in the top-left. Under 4 rotations \u00d7 2 mirrors = 8 transformations, each pattern "visits" all four corners and all four edges. This means the network evaluates the full board despite defining patterns in only one region &mdash; no positions are missed.</div>`;
    ex += '</div>';

    // Point 7: 6-tuple sweet spot
    ex += '<div class="why-point">';
    ex += `<span class="why-icon" style="background:#34495e">7</span>`;
    ex += `<div class="why-text"><strong>6 is the sweet spot for tuple size.</strong> Each position holds a tile value 0\u201315, so a 6-tuple needs 16<sup>6</sup> = 16.7M weights. With 4 patterns that\u2019s ~67M weights (~256 MB) &mdash; large enough to encode complex patterns, small enough to fit in memory and train in hours. A 7-tuple would need 268M weights <em>per pattern</em>, making training impractical.</div>`;
    ex += '</div>';

    // Summary
    ex += '<div style="margin-top:10px;padding:8px 10px;background:var(--bg);border-radius:6px;border-left:3px solid var(--accent);font-size:0.72rem;line-height:1.6">';
    ex += '<strong>In total:</strong> 4 patterns \u00d7 8 symmetries = <strong>32 weight lookups per board evaluation</strong>. The network stores 4 \u00d7 16<sup>6</sup> \u2248 <strong>67M learnable weights</strong>, trained end-to-end through self-play using TD(0). These specific patterns are from the academic literature (Szubert &amp; Ja\u015Bkowski, 2014; Wu et al., 2014) and have been shown to achieve the best trade-off between expressiveness and tractability for 2048.';
    ex += '</div>';

    ex += '</div>';
    explain.innerHTML = ex;
  },

  renderTDLWalkthrough(analysis, currentBoard) {
    const wt = document.getElementById('teach-walkthrough');
    const best = analysis.results[analysis.bestIdx];
    if (!best || !best.perPattern) {
      wt.style.display = 'none';
      return;
    }
    wt.style.display = 'block';

    // Use the first pattern for the detailed example
    const exPattern = best.perPattern[0];
    const exDetailed = exPattern.detailed;

    // Helper: mini position grid highlighting specific positions
    function posGrid(activePositions, color) {
      const s = new Set(activePositions);
      let h = '<span class="walk-pos-grid">';
      for (let i = 0; i < 16; i++) {
        if (s.has(i)) {
          h += `<span class="wp-cell wp-active" style="background:${color || 'var(--accent)'}">${i}</span>`;
        } else {
          h += '<span class="wp-cell wp-inactive"></span>';
        }
      }
      return h + '</span>';
    }

    let html = '<h4>Step-by-Step: How TDL Picks a Move</h4>';

    // ── Step 1: Current Board ──
    html += '<div class="walk-step" data-step="1">';
    html += '<h5>Start with the current board</h5>';
    html += '<p>The board has 16 cells. Each tile is stored as its log\u2082 value (e.g. tile 8 \u2192 value 3, tile 512 \u2192 value 9, empty \u2192 0).</p>';
    html += Teacher.miniBoard(currentBoard);
    html += '</div>';

    // ── Step 2: Simulate all moves ──
    html += '<div class="walk-step" data-step="2">';
    html += '<h5>Simulate each move to get afterstates</h5>';
    html += '<p>For each direction, slide and merge tiles (but do <strong>not</strong> add a random tile yet). This "afterstate" is what the network evaluates.</p>';
    html += '<div class="walk-pipeline">';
    for (const r of analysis.results) {
      if (!r.valid) {
        html += `<div class="pipe-box" style="opacity:0.3"><small>${DIR_NAMES[r.dir]}</small>\u2715 invalid</div>`;
      } else {
        const isBest = r === best;
        html += `<div class="pipe-box${isBest ? ' pipe-best' : ''}"><small>${Teacher.DIR_ARROWS[r.dir]} ${DIR_NAMES[r.dir]}${isBest ? ' \u2605' : ''}</small>R = +${r.moveScore}</div>`;
      }
    }
    html += '</div></div>';

    // ── Step 3: Evaluate V(s') ──
    html += '<div class="walk-step" data-step="3">';
    html += `<h5>Evaluate V(s\u2032) for the ${Teacher.DIR_ARROWS[best.dir]} ${DIR_NAMES[best.dir]} afterstate</h5>`;
    html += '<p>The N-tuple network computes <code>V(s\u2032)</code> by reading tile values at specific positions, combining them into an index, and looking up a learned weight. This is done for each of the <strong>4 patterns \u00d7 8 symmetries = 32 lookups</strong>.</p>';

    // Show the afterstate board
    html += Teacher.miniBoard(best.afterstate);

    // ── Shared-table callout ──
    html += '<div style="margin:10px 0;padding:8px 12px;background:rgba(52,152,219,0.08);border:1px solid rgba(52,152,219,0.25);border-radius:6px;font-size:0.7rem;line-height:1.6">';
    html += '<strong style="color:#3498db">Key insight: One table per pattern, shared across all 8 symmetries.</strong><br>';
    html += 'Each pattern has a <strong>single</strong> weight table with 16<sup>6</sup> = 16,777,216 entries. ';
    html += 'All 8 symmetries (rotations + mirrors) compute different indices into this <strong>same</strong> table. ';
    html += 'That is how rotational invariance works &mdash; if the network learns "a descending row is good," that knowledge ';
    html += 'automatically applies to all 8 orientations. Total tables: <strong>4</strong> (one per pattern).';
    html += '</div>';

    // Detailed example: Pattern P1, all 8 symmetries
    html += `<p style="margin-top:8px"><strong>Detailed lookup for <span style="color:${Teacher.PATTERN_COLORS[0]}">Pattern P1</span></strong> [${exPattern.positions.join(', ')}] &mdash; all 8 symmetries index into the <strong>same table</strong> of ${(tdlNetwork.patterns[0] ? (tdlNetwork.patterns[0].weights.length).toLocaleString() : '16,777,216')} weights:</p>`;

    html += '<table class="sym-table">';
    html += '<tr><th>Symmetry</th><th>Positions read</th><th>Tile values</th><th>Index (into same table)</th><th>Weight</th></tr>';

    let symTotal = 0;
    for (const d of exDetailed) {
      const symName = NTuple.SYM_NAMES[d.symIndex];
      const isIdentity = d.symIndex === 0;
      const cls = isIdentity ? ' class="sym-identity"' : '';
      const posStr = '[' + d.positions.join(',') + ']';
      const tileStr = '[' + d.tiles.join(',') + ']';
      const idxHex = '0x' + d.index.toString(16).toUpperCase().padStart(6, '0');
      const wStr = d.weight >= 0 ? '+' + Teacher.fmt(d.weight, 1) : Teacher.fmt(d.weight, 1);
      symTotal += d.weight;

      html += `<tr${cls}>`;
      html += `<td>${symName}${isIdentity ? ' \u25c0' : ''}</td>`;
      html += `<td>${posStr}</td>`;
      html += `<td>${tileStr}</td>`;
      html += `<td>${idxHex}</td>`;
      html += `<td>${wStr}</td>`;
      html += '</tr>';
    }
    html += `<tr class="sym-total"><td>P1 subtotal</td><td></td><td></td><td></td><td>${Teacher.fmt(symTotal, 1)}</td></tr>`;
    html += '</table>';

    // Identity explanation
    const id0 = exDetailed[0];
    html += '<p style="font-size:0.65rem;opacity:0.6;margin-top:4px">';
    html += `<strong>\u25c0 Identity row explained:</strong> Read tiles at positions [${id0.positions.join(',')}] from the afterstate. `;
    html += `Got values [${id0.tiles.join(',')}]. `;
    html += `Pack into index: ${id0.tiles.map((t,i) => t + '\u00d716<sup>'+i+'</sup>').join(' + ')} = 0x${id0.index.toString(16).toUpperCase().padStart(6,'0')}. `;
    html += `Look up <code>weights[${id0.index}]</code> = ${id0.weight >= 0 ? '+' : ''}${Teacher.fmt(id0.weight, 1)}.`;
    html += '</p>';

    // Show click-to-expand for remaining patterns
    html += '<span class="walk-toggle" onclick="this.nextElementSibling.classList.toggle(\'open\')">Show all 4 patterns \u25BC</span>';
    html += '<div class="walk-collapsible">';
    for (let p = 0; p < best.perPattern.length; p++) {
      const pp = best.perPattern[p];
      const detail = pp.detailed;
      let pTotal = 0;
      html += `<p style="margin-top:8px"><strong style="color:${Teacher.PATTERN_COLORS[p]}">Pattern P${p+1}</strong> [${pp.positions.join(', ')}] (same table, different symmetry positions):</p>`;
      html += '<table class="sym-table">';
      html += '<tr><th>Symmetry</th><th>Positions</th><th>Tiles</th><th>Index</th><th>Weight</th></tr>';
      for (const d of detail) {
        const symName = NTuple.SYM_NAMES[d.symIndex];
        const wStr = d.weight >= 0 ? '+' + Teacher.fmt(d.weight, 1) : Teacher.fmt(d.weight, 1);
        pTotal += d.weight;
        html += `<tr><td>${symName}</td><td>[${d.positions.join(',')}]</td><td>[${d.tiles.join(',')}]</td><td>0x${d.index.toString(16).toUpperCase().padStart(6,'0')}</td><td>${wStr}</td></tr>`;
      }
      html += `<tr class="sym-total"><td>P${p+1} subtotal</td><td></td><td></td><td></td><td>${Teacher.fmt(pTotal, 1)}</td></tr>`;
      html += '</table>';
    }
    html += '</div>'; // collapsible

    html += '</div>'; // step 3

    // ── Step 4: Final decision ──
    html += '<div class="walk-step" data-step="4">';
    html += '<h5>Compare Total = R(s,a) + V(s\u2032) for each move</h5>';

    html += '<table class="sym-table" style="font-size:0.68rem">';
    html += '<tr><th>Move</th><th>R(s,a)</th><th>V(s\u2032)</th><th>Total</th><th></th></tr>';
    for (const r of analysis.results) {
      if (!r.valid) {
        html += `<tr style="opacity:0.3"><td>${Teacher.DIR_ARROWS[r.dir]} ${DIR_NAMES[r.dir]}</td><td>\u2014</td><td>\u2014</td><td>\u2014</td><td>invalid</td></tr>`;
      } else {
        const isBest = r === best;
        const mark = isBest ? '<strong style="color:#4caf50">\u2605 BEST</strong>' : '';
        html += `<tr${isBest ? ' style="font-weight:700"' : ''}>`;
        html += `<td>${Teacher.DIR_ARROWS[r.dir]} ${DIR_NAMES[r.dir]}</td>`;
        html += `<td>+${Teacher.fmt(r.moveScore)}</td>`;
        html += `<td>${Teacher.fmt(r.networkVal, 1)}</td>`;
        html += `<td>${Teacher.fmt(r.total, 1)}</td>`;
        html += `<td>${mark}</td>`;
        html += '</tr>';
      }
    }
    html += '</table>';

    html += `<p style="margin-top:6px">The network picks <strong>${Teacher.DIR_ARROWS[best.dir]} ${DIR_NAMES[best.dir]}</strong> because it has the highest Total = ${Teacher.fmt(best.moveScore)} + ${Teacher.fmt(best.networkVal, 1)} = <strong>${Teacher.fmt(best.total, 1)}</strong>.</p>`;
    html += '</div>';

    // ── Step 5: How weights are updated (training) ──
    html += '<div class="walk-step" data-step="5">';
    html += '<h5>How are these weights learned? (TD(0) Training)</h5>';

    html += '<p>During play, the network only <em>reads</em> weights. But during <strong>training</strong>, after each full game, it <em>updates</em> them via a backward pass. Here\'s the process:</p>';

    // Sub-step A: Forward play
    html += '<div style="margin:8px 0;padding:8px 12px;background:var(--bg);border-radius:6px;border-left:3px solid #3498db">';
    html += '<strong style="font-size:0.72rem">A. Play a full game, recording the path</strong>';
    html += '<p style="font-size:0.68rem;margin:4px 0;line-height:1.6">';
    html += 'At each turn, the network picks the best move (max <code>R + V(s\')</code>), records the <strong>afterstate</strong> and its <strong>reward</strong>, then a random tile is added and the game continues.</p>';
    html += '<div style="font-family:var(--mono);font-size:0.64rem;line-height:1.6;opacity:0.8;margin:4px 0">';
    html += 'path = [<br>';
    html += '&nbsp;&nbsp;{ afterstate: s\'<sub>0</sub>, reward: R<sub>0</sub> }, &nbsp; <span style="opacity:0.5">// move 0: e.g. \u2190 merged two 4s, R=8</span><br>';
    html += '&nbsp;&nbsp;{ afterstate: s\'<sub>1</sub>, reward: R<sub>1</sub> }, &nbsp; <span style="opacity:0.5">// move 1: e.g. \u2191 rearranged, R=0 (preparation!)</span><br>';
    html += '&nbsp;&nbsp;{ afterstate: s\'<sub>2</sub>, reward: R<sub>2</sub> }, &nbsp; <span style="opacity:0.5">// move 2: e.g. \u2192 merged two 8s, R=16</span><br>';
    html += '&nbsp;&nbsp;...<br>';
    html += '&nbsp;&nbsp;{ afterstate: s\'<sub>N</sub>, reward: R<sub>N</sub> }, &nbsp; <span style="opacity:0.5">// last move before game over</span><br>';
    html += ']';
    html += '</div></div>';

    // Sub-step B: Backward pass
    html += '<div style="margin:8px 0;padding:8px 12px;background:var(--bg);border-radius:6px;border-left:3px solid #e74c3c">';
    html += '<strong style="font-size:0.72rem">B. Walk backward, updating weights at each step</strong>';
    html += '<p style="font-size:0.68rem;margin:4px 0;line-height:1.6">Starting from the end of the game (where <code>V = 0</code>, game over), propagate value backward:</p>';
    html += '<div style="font-family:var(--mono);font-size:0.64rem;line-height:2;margin:6px 0">';
    html += 'target = 0 &nbsp; <span style="opacity:0.5">// terminal state: nothing left to gain</span><br>';
    html += '<strong>for i = N down to 0:</strong><br>';
    html += '&nbsp;&nbsp;error = target \u2212 V(s\'<sub>i</sub>) &nbsp; <span style="opacity:0.5">// how wrong is the current estimate?</span><br>';
    html += '&nbsp;&nbsp;V(s\'<sub>i</sub>) += \u03b1 \u00d7 error &nbsp; <span style="opacity:0.5">// nudge the 32 weights that V reads from</span><br>';
    html += '&nbsp;&nbsp;target = R<sub>i</sub> + V(s\'<sub>i</sub>) &nbsp; <span style="opacity:0.5">// pass value to the previous step</span>';
    html += '</div></div>';

    // Sub-step C: How preparation moves get credit
    html += '<div style="margin:8px 0;padding:8px 12px;background:rgba(255,152,0,0.08);border-radius:6px;border-left:3px solid #ff9800">';
    html += '<strong style="font-size:0.72rem;color:#ff9800">C. How "preparation moves" earn credit</strong>';
    html += '<p style="font-size:0.68rem;margin:4px 0;line-height:1.6">Consider a game fragment where:</p>';
    html += '<div style="font-family:var(--mono);font-size:0.64rem;line-height:2;margin:6px 0">';
    html += '<span style="color:#ff9800;font-weight:700">Step 5: \u2191 Up</span> &mdash; rearranged tiles, <strong>R = 0</strong> (no merge!)<br>';
    html += '<span style="color:#4caf50;font-weight:700">Step 6: \u2192 Right</span> &mdash; merged two 128s, <strong>R = 256</strong><br>';
    html += '<span style="color:#4caf50;font-weight:700">Step 7: \u2190 Left</span> &mdash; merged two 64s, <strong>R = 128</strong>';
    html += '</div>';
    html += '<p style="font-size:0.68rem;margin:4px 0;line-height:1.6">The backward pass processes step 7 first, then 6, then 5:</p>';
    html += '<table style="font-size:0.64rem;font-family:var(--mono);width:100%;border-collapse:collapse;margin:4px 0">';
    html += '<tr style="border-bottom:1px solid var(--card-border)"><th style="text-align:left;padding:3px 6px">Step</th><th style="text-align:left;padding:3px 6px">R</th><th style="text-align:left;padding:3px 6px">old V(s\')</th><th style="text-align:left;padding:3px 6px">target</th><th style="text-align:left;padding:3px 6px">error</th><th style="text-align:left;padding:3px 6px">new V(s\')</th></tr>';
    html += '<tr style="color:#4caf50"><td style="padding:3px 6px">Step 7 (last)</td><td style="padding:3px 6px">128</td><td style="padding:3px 6px">50</td><td style="padding:3px 6px">0</td><td style="padding:3px 6px">\u221250</td><td style="padding:3px 6px">49.5</td></tr>';
    html += '<tr style="color:#4caf50"><td style="padding:3px 6px">Step 6</td><td style="padding:3px 6px">256</td><td style="padding:3px 6px">100</td><td style="padding:3px 6px">128 + 49.5 = 177.5</td><td style="padding:3px 6px">+77.5</td><td style="padding:3px 6px">100.8</td></tr>';
    html += '<tr style="color:#ff9800;font-weight:700"><td style="padding:3px 6px">Step 5 \u2605</td><td style="padding:3px 6px">0</td><td style="padding:3px 6px">200</td><td style="padding:3px 6px">256 + 100.8 = 356.8</td><td style="padding:3px 6px">+156.8</td><td style="padding:3px 6px">201.6</td></tr>';
    html += '</table>';
    html += '<p style="font-size:0.68rem;margin:6px 0;line-height:1.6">';
    html += '<strong style="color:#ff9800">Step 5 had R = 0</strong> (no merge) but its V(s\') <em>increased</em> because the backward pass carried ';
    html += 'the combined value of steps 6 + 7 (R=256+128) backward through the <code>target = R + V(s\')</code> chain. ';
    html += 'The network now knows: <em>that specific board configuration (the afterstate of the "preparation" move) is worth ~201 points of future score.</em> ';
    html += 'Over thousands of games, these weight updates accumulate. The 32 weights that were read when evaluating s\'<sub>5</sub> each get nudged upward, ';
    html += 'encoding the lesson: "this pattern of tiles leads to good things."';
    html += '</p></div>';

    // Sub-step D: What exactly gets updated
    html += '<div style="margin:8px 0;padding:8px 12px;background:var(--bg);border-radius:6px;border-left:3px solid #9b59b6">';
    html += '<strong style="font-size:0.72rem">D. What exactly changes in the weight tables?</strong>';
    html += '<p style="font-size:0.68rem;margin:4px 0;line-height:1.6">';
    html += 'When we "update V(s\')" we adjust the <strong>32 specific weights</strong> that were read during evaluation ';
    html += '(4 patterns \u00d7 8 symmetries = 32 lookups, each into its pattern\'s table). The adjustment <code>\u03b1 \u00d7 error</code> ';
    html += 'is divided evenly: each pattern gets <code>\u03b1 \u00d7 error / 4</code>, and within a pattern, each of the 8 symmetry lookups gets <code>\u03b1 \u00d7 error / 32</code>. ';
    html += 'So each of the 32 specific table entries gets a tiny nudge. Over millions of games, these tiny nudges converge to a value function that ';
    html += 'accurately predicts the expected future score from any board position.';
    html += '</p></div>';

    // Summary callout
    html += '<div style="margin:8px 0;padding:10px 12px;background:rgba(76,175,80,0.06);border:1px solid rgba(76,175,80,0.2);border-radius:6px;font-size:0.7rem;line-height:1.6">';
    html += '<strong style="color:#4caf50">The big picture:</strong> ';
    html += 'The network plays itself \u2192 records every afterstate + reward \u2192 walks backward updating V so it better predicts the future. ';
    html += 'Moves that didn\'t score any points but led to big merges get "credit" via the backward chain. ';
    html += 'This is <strong>Temporal Difference Learning</strong>: the network doesn\'t need to know the optimal strategy in advance &mdash; ';
    html += 'it discovers that some board shapes are intrinsically valuable by observing what happens after them, game after game. ';
    html += 'Try the <strong>Train</strong> button below to watch this process live!';
    html += '</div>';

    html += '</div>'; // step 5

    wt.innerHTML = html;
  },

  renderHeuristicDetail(analysis) {
    const container = document.getElementById('teach-heuristic-detail');
    const bestResult = analysis.results[analysis.bestIdx];
    if (!bestResult) {
      container.style.display = 'none';
      return;
    }

    container.style.display = 'block';

    const maxWeighted = Math.max(...bestResult.components.map(c => Math.abs(c.weighted)), 1);

    let html = '<div style="margin-top:12px"><h4 style="font-size:0.75rem;font-weight:700;margin-bottom:8px">Component Breakdown (best move)</h4>';
    html += '<div class="heur-bars">';

    for (const comp of bestResult.components) {
      const pct = Math.max(0, Math.min(100, (Math.abs(comp.weighted) / maxWeighted) * 100));
      const color = Teacher.HEUR_COLORS[comp.name] || '#999';
      html += `<div class="heur-bar-row">
        <span class="heur-bar-label">${comp.name}</span>
        <div class="heur-bar"><div class="heur-bar-fill" style="width:${pct}%;background:${color}"></div></div>
        <span class="heur-bar-val">${Teacher.fmt(comp.weighted, 0)}</span>
      </div>`;
    }

    html += '</div>';
    html += `<div style="font-size:0.65rem;opacity:0.5;margin-top:4px;font-family:var(--mono)">
      Raw values are multiplied by weights: ${bestResult.components.map(c => c.name + '×' + c.weight).join(', ')}
    </div>`;
    html += '</div>';
    container.innerHTML = html;
  },

  /** Main render entry point */
  render(board, playerType) {
    const panel = document.getElementById('teach-panel');
    const explain = document.getElementById('teach-explain');
    const formula = document.getElementById('teach-formula');
    const tag = document.getElementById('teach-player-tag');
    const patternsSection = document.getElementById('teach-patterns-section');
    const patternViz = document.getElementById('teach-pattern-viz');
    const heurDetail = document.getElementById('teach-heuristic-detail');
    const walkthrough = document.getElementById('teach-walkthrough');

    // Hide optional sections
    patternsSection.style.display = 'none';
    patternViz.style.display = 'none';
    heurDetail.style.display = 'none';
    walkthrough.style.display = 'none';
    formula.style.display = 'none';

    let analysis;

    switch (playerType) {
      case 'tdl':
        tag.textContent = 'TDL';
        explain.innerHTML = `The <strong>TDL player</strong> uses a learned value function <code>V(s)</code> to evaluate board positions. For each valid move, it simulates the move to get the <strong>afterstate</strong> <code>s'</code> (board after sliding, before random tile), then picks the move maximizing the total value.`;
        formula.style.display = 'block';
        formula.innerHTML = 'Choose a* = argmax<sub>a</sub> [ R(s,a) + V(s\') ]';

        if (!tdlNetwork.loaded) {
          explain.innerHTML += '<br><br><strong style="color:#e74c3c">Load weights.bin to see TDL analysis.</strong>';
          document.getElementById('teach-moves').innerHTML = '';
          return;
        }

        analysis = Teacher.analyzeTDL(board);
        Teacher.renderMoveCards(analysis);
        Teacher.renderTDLWalkthrough(analysis, board);
        Teacher.renderTDLPatternBreakdown(analysis);
        Teacher.renderPatternViz();
        break;

      case 'heuristic':
        tag.textContent = 'Heuristic';
        explain.innerHTML = `The <strong>Heuristic player</strong> evaluates each afterstate using a weighted combination of hand-crafted features. It picks the move whose afterstate has the highest evaluation score.`;
        formula.style.display = 'block';
        formula.innerHTML = 'Eval(s\') = &Sigma; weight<sub>i</sub> &times; feature<sub>i</sub>(s\')';
        analysis = Teacher.analyzeHeuristic(board);
        Teacher.renderMoveCards(analysis);
        Teacher.renderHeuristicDetail(analysis);
        break;

      case 'expectimax':
      case 'expectimax-deep':
        const depth = playerType === 'expectimax-deep' ? 5 : 3;
        tag.textContent = `Expectimax d=${depth}`;
        explain.innerHTML = `The <strong>Expectimax player</strong> searches a game tree with alternating <strong>MAX</strong> nodes (player picks best move) and <strong>CHANCE</strong> nodes (random tile: 90% &ldquo;2&rdquo;, 10% &ldquo;4&rdquo;). It computes the expected value of each move by averaging over all possible random tile placements, searching <strong>${depth} levels</strong> deep.`;
        analysis = Teacher.analyzeExpectimax(board, depth);
        Teacher.renderMoveCards(analysis);
        break;

      case 'random':
        tag.textContent = 'Random';
        explain.innerHTML = `The <strong>Random player</strong> picks uniformly at random among all valid moves. No evaluation, no strategy &mdash; just pure luck. A useful baseline to compare smarter players against.`;
        analysis = Teacher.analyzeRandom(board);
        Teacher.renderMoveCards(analysis);
        break;

      case 'human':
        tag.textContent = 'Human';
        explain.innerHTML = `You're playing manually! The analysis below shows how a <strong>Heuristic AI</strong> would evaluate each possible move from this position, so you can compare your intuition against the AI.`;
        formula.style.display = 'block';
        formula.innerHTML = 'Eval(s\') = &Sigma; weight<sub>i</sub> &times; feature<sub>i</sub>(s\')';
        analysis = Teacher.analyzeHeuristic(board);
        Teacher.renderMoveCards(analysis);
        Teacher.renderHeuristicDetail(analysis);
        break;

      default:
        tag.textContent = '—';
        explain.textContent = 'Select a player to see move analysis.';
        document.getElementById('teach-moves').innerHTML = '';
    }
  },
};


// ═══════════════════════════════════════════════════════════
//  GAME UI
// ═══════════════════════════════════════════════════════════

class GameUI {
  constructor() {
    this.board = new Board2048();
    this.score = 0;
    this.bestScore = parseInt(localStorage.getItem('2048-best') || '0');
    this.moveCount = 0;
    this.aiRunning = false;
    this.aiTimer = null;
    this.gameOver = false;
    this.won = false;
    this.keepPlaying = false;
    this.history = []; // undo stack
    this.maxHistorySize = 50;
    this.teacherMode = false;

    // DOM
    this.boardEl = document.getElementById('board');
    this.tileLayer = document.getElementById('tile-layer');
    this.scoreEl = document.getElementById('score');
    this.bestScoreEl = document.getElementById('best-score');
    this.movesEl = document.getElementById('moves');
    this.maxTileEl = document.getElementById('max-tile');
    this.overlayEl = document.getElementById('game-over-overlay');
    this.overlayMsg = document.getElementById('overlay-message');
    this.statusEl = document.getElementById('ai-status');
    this.playerSelect = document.getElementById('player-select');
    this.speedSlider = document.getElementById('speed-slider');
    this.speedLabel = document.getElementById('speed-label');
    this.btnPlay = document.getElementById('btn-play');
    this.teachPanel = document.getElementById('teach-panel');
    this.btnTeacher = document.getElementById('btn-teacher');

    this.tileElements = new Map(); // id -> DOM element
    this.nextTileId = 0;
    this.tileData = []; // { id, row, col, val, merged }

    this.init();
  }

  init() {
    this.board.addRandomTile();
    this.board.addRandomTile();
    this.updateDisplay();
    this.renderTiles();
    this.bindEvents();
    this.updateSpeedLabel();
  }

  bindEvents() {
    // Keyboard
    document.addEventListener('keydown', (e) => this.handleKey(e));

    // Touch / swipe
    let startX, startY;
    const wrapper = document.getElementById('board-wrapper');
    wrapper.addEventListener('touchstart', (e) => {
      startX = e.touches[0].clientX;
      startY = e.touches[0].clientY;
    }, { passive: true });
    wrapper.addEventListener('touchend', (e) => {
      if (startX == null) return;
      const dx = e.changedTouches[0].clientX - startX;
      const dy = e.changedTouches[0].clientY - startY;
      const absDx = Math.abs(dx), absDy = Math.abs(dy);
      if (Math.max(absDx, absDy) < 20) return;
      if (absDx > absDy) {
        this.humanMove(dx > 0 ? DIRECTIONS.RIGHT : DIRECTIONS.LEFT);
      } else {
        this.humanMove(dy > 0 ? DIRECTIONS.DOWN : DIRECTIONS.UP);
      }
      startX = startY = null;
    }, { passive: true });

    // Speed slider
    this.speedSlider.addEventListener('input', () => {
      this.updateSpeedLabel();
      if (this.aiRunning) {
        this.stopAI();
        this.startAI();
      }
    });

    // Player select — show/hide TDL upload row & update teacher
    this.playerSelect.addEventListener('change', () => {
      this.updateTDLUploadVisibility();
      this.updateTeacher();
    });
    this.updateTDLUploadVisibility();

    // TDL weight file upload
    document.getElementById('weights-file').addEventListener('change', (e) => {
      this.loadWeightsFile(e.target.files[0]);
    });
  }

  updateTDLUploadVisibility() {
    const row = document.getElementById('tdl-upload-row');
    if (this.getSelectedPlayer() === 'tdl') {
      row.classList.add('visible');
    } else {
      row.classList.remove('visible');
    }
  }

  loadWeightsFile(file) {
    if (!file) return;

    const info = document.getElementById('tdl-info');
    const progress = document.getElementById('tdl-progress');
    const progressBar = document.getElementById('tdl-progress-bar');
    const btn = document.getElementById('btn-load-weights');

    info.textContent = `Loading ${file.name} (${(file.size / 1024 / 1024).toFixed(0)} MB)...`;
    progress.classList.add('visible');
    progressBar.style.width = '0%';

    const reader = new FileReader();

    reader.onprogress = (e) => {
      if (e.lengthComputable) {
        progressBar.style.width = `${(e.loaded / e.total * 100).toFixed(0)}%`;
      }
    };

    reader.onload = (e) => {
      progressBar.style.width = '100%';
      const buffer = e.target.result;

      try {
        const success = tdlNetwork.loadFromBuffer(buffer, (frac) => {
          progressBar.style.width = `${(frac * 100).toFixed(0)}%`;
        });

        if (success) {
          const numWeights = tdlNetwork.patterns.reduce((s, p) => s + p.tableSize, 0);
          info.textContent = `Loaded: ${tdlNetwork.patterns.length} patterns, ${(numWeights / 1e6).toFixed(1)}M weights`;
          btn.textContent = 'Weights loaded';
          btn.classList.add('loaded');
          this.setStatus('TDL weights loaded — ready to play!');
        } else {
          info.textContent = 'Error: invalid weight file format';
          this.setStatus('Failed to load weights');
        }
      } catch (err) {
        console.error('Weight loading error:', err);
        info.textContent = `Error: ${err.message}`;
        this.setStatus('Failed to load weights');
      }

      setTimeout(() => progress.classList.remove('visible'), 1000);
    };

    reader.onerror = () => {
      info.textContent = 'Error reading file';
      progress.classList.remove('visible');
    };

    reader.readAsArrayBuffer(file);
  }

  handleKey(e) {
    const key = e.key;
    let dir = null;

    switch (key) {
      case 'ArrowLeft': case 'a': case 'A': dir = DIRECTIONS.LEFT; break;
      case 'ArrowRight': case 'd': case 'D': dir = DIRECTIONS.RIGHT; break;
      case 'ArrowUp': case 'w': case 'W': dir = DIRECTIONS.UP; break;
      case 'ArrowDown': case 's': case 'S': dir = DIRECTIONS.DOWN; break;
      case ' ':
        e.preventDefault();
        this.toggleAI();
        return;
      case 'n': case 'N':
        this.restart();
        return;
      case 'z': case 'Z':
        if (e.ctrlKey || e.metaKey) {
          e.preventDefault();
          this.undo();
        } else {
          this.undo();
        }
        return;
      case 't': case 'T':
        this.toggleTeacher();
        return;
    }

    if (dir !== null) {
      e.preventDefault();
      this.humanMove(dir);
    }
  }

  getDelay() {
    // Map slider 0-100 to delay 1000ms - 1ms (log scale)
    const val = parseInt(this.speedSlider.value);
    const minLog = Math.log(1);
    const maxLog = Math.log(1000);
    const delay = Math.exp(maxLog - (val / 100) * (maxLog - minLog));
    return Math.round(delay);
  }

  updateSpeedLabel() {
    const delay = this.getDelay();
    this.speedLabel.textContent = delay >= 1000 ? `${(delay/1000).toFixed(1)}s` :
                                   delay + 'ms';
  }

  pushHistory() {
    this.history.push({
      grid: this.board.grid.slice(),
      score: this.score,
      moveCount: this.moveCount,
      gameOver: this.gameOver,
      won: this.won,
      keepPlaying: this.keepPlaying,
      tileData: JSON.parse(JSON.stringify(this.tileData)),
    });
    if (this.history.length > this.maxHistorySize) this.history.shift();
  }

  undo() {
    if (this.history.length === 0) return;
    if (this.aiRunning) this.stopAI();

    const state = this.history.pop();
    this.board.grid = state.grid;
    this.score = state.score;
    this.moveCount = state.moveCount;
    this.gameOver = state.gameOver;
    this.won = state.won;
    this.keepPlaying = state.keepPlaying;
    this.tileData = state.tileData;

    this.overlayEl.classList.remove('active');
    this.rebuildTileElements();
    this.updateDisplay();
    this.updateTeacher();
  }

  humanMove(direction) {
    if (this.gameOver && !this.keepPlaying) return;
    if (this.aiRunning) return;
    this.makeMove(direction);
  }

  makeMove(direction) {
    if (this.gameOver && !this.keepPlaying) return;

    const result = Board2048.move(this.board, direction);
    if (!result.moved) return;

    this.pushHistory();

    // Track tile movement for rendering
    this.board = result.board;
    this.score += result.score;
    this.moveCount++;

    if (this.score > this.bestScore) {
      this.bestScore = this.score;
      localStorage.setItem('2048-best', this.bestScore.toString());
    }

    // Add random tile
    const newTile = this.board.addRandomTile();

    // Check win
    if (!this.won && this.board.getMaxTile() >= 2048) {
      this.won = true;
      // Don't stop - let user keep playing or AI continue
    }

    // Check game over
    if (this.board.isGameOver()) {
      this.gameOver = true;
      this.showOverlay('Game Over!');
      this.stopAI();
    }

    this.renderTiles(newTile);
    this.updateDisplay();
    this.updateTeacher();
  }

  renderTiles(newTilePos) {
    // Clear old tile elements
    this.tileLayer.innerHTML = '';
    this.tileElements.clear();

    const layerRect = this.tileLayer.getBoundingClientRect();
    const cellSize = layerRect.width / 4;
    const gap = layerRect.width * 0.022 / (1 - 0.022 * 3) * 0; // gap handled by grid

    // Calculate positions based on percentage
    const cellPercent = (100 - 2.2 * 3) / 4; // subtract gaps
    const gapPercent = 2.2;

    // Build new tile data
    this.tileData = [];
    for (let r = 0; r < 4; r++) {
      for (let c = 0; c < 4; c++) {
        const val = this.board.getTile(r, c);
        if (val === 0) continue;
        const id = this.nextTileId++;
        const isNew = newTilePos && newTilePos.row === r && newTilePos.col === c;
        const isMerged = false;
        this.tileData.push({ id, row: r, col: c, val, isNew, isMerged });
      }
    }

    for (const td of this.tileData) {
      const el = document.createElement('div');
      const displayVal = 1 << td.val;
      const tileClass = displayVal <= 8192 ? `tile-${displayVal}` : 'tile-super';

      // Font size based on digit count
      const digits = displayVal.toString().length;
      let fontSize;
      if (digits <= 2) fontSize = '2rem';
      else if (digits === 3) fontSize = '1.7rem';
      else if (digits === 4) fontSize = '1.35rem';
      else fontSize = '1.1rem';

      // Position using percentages
      const left = td.col * (cellPercent + gapPercent);
      const top = td.row * (cellPercent + gapPercent);

      el.className = `tile ${tileClass}${td.isNew ? ' new-tile' : ''}`;
      el.style.cssText = `
        width: ${cellPercent}%;
        height: ${cellPercent}%;
        left: ${left}%;
        top: ${top}%;
        font-size: ${fontSize};
        line-height: 1;
      `;
      el.textContent = displayVal;

      this.tileLayer.appendChild(el);
    }
  }

  rebuildTileElements() {
    this.tileLayer.innerHTML = '';
    const cellPercent = (100 - 2.2 * 3) / 4;
    const gapPercent = 2.2;

    for (const td of this.tileData) {
      const el = document.createElement('div');
      const displayVal = 1 << td.val;
      const tileClass = displayVal <= 8192 ? `tile-${displayVal}` : 'tile-super';

      const digits = displayVal.toString().length;
      let fontSize;
      if (digits <= 2) fontSize = '2rem';
      else if (digits === 3) fontSize = '1.7rem';
      else if (digits === 4) fontSize = '1.35rem';
      else fontSize = '1.1rem';

      const left = td.col * (cellPercent + gapPercent);
      const top = td.row * (cellPercent + gapPercent);

      el.className = `tile ${tileClass}`;
      el.style.cssText = `
        width: ${cellPercent}%;
        height: ${cellPercent}%;
        left: ${left}%;
        top: ${top}%;
        font-size: ${fontSize};
        line-height: 1;
      `;
      el.textContent = displayVal;
      this.tileLayer.appendChild(el);
    }
  }

  updateDisplay() {
    this.scoreEl.textContent = this.score.toLocaleString();
    this.bestScoreEl.textContent = this.bestScore.toLocaleString();
    this.movesEl.textContent = this.moveCount.toLocaleString();
    this.maxTileEl.textContent = this.board.getMaxTile().toLocaleString();
  }

  showOverlay(message) {
    this.overlayMsg.textContent = message;
    this.overlayEl.classList.add('active');
  }

  hideOverlay() {
    this.overlayEl.classList.remove('active');
  }

  restart() {
    this.stopAI();
    this.board = new Board2048();
    this.score = 0;
    this.moveCount = 0;
    this.gameOver = false;
    this.won = false;
    this.keepPlaying = false;
    this.history = [];
    this.tileData = [];
    this.nextTileId = 0;
    this.hideOverlay();

    this.board.addRandomTile();
    this.board.addRandomTile();

    this.renderTiles();
    this.updateDisplay();
    this.setStatus('');
    this.updateTeacher();
  }

  // ── AI Controls ──

  getSelectedPlayer() {
    return this.playerSelect.value;
  }

  chooseAIMove() {
    const player = this.getSelectedPlayer();
    switch (player) {
      case 'random':
        return AI.random(this.board);
      case 'heuristic':
        return AI.heuristic(this.board);
      case 'expectimax':
        return AI.expectimax(this.board, 3);
      case 'expectimax-deep':
        return AI.expectimax(this.board, 5);
      case 'tdl':
        return AI.tdl(this.board);
      default:
        return null;
    }
  }

  toggleAI() {
    if (this.aiRunning) {
      this.stopAI();
    } else {
      this.startAI();
    }
  }

  startAI() {
    const player = this.getSelectedPlayer();
    if (player === 'human') {
      this.setStatus('Select an AI player first');
      return;
    }
    if (player === 'tdl' && !tdlNetwork.loaded) {
      this.setStatus('Load weights.bin first (use the button above)');
      return;
    }
    if (this.gameOver) {
      this.setStatus('Game is over — start a new game');
      return;
    }

    this.aiRunning = true;
    this.btnPlay.textContent = '⏸ Pause';
    this.btnPlay.classList.add('active');
    this.setStatus(`Running: ${this.playerSelect.selectedOptions[0].text}`);
    this.aiStep();
  }

  stopAI() {
    this.aiRunning = false;
    if (this.aiTimer) {
      clearTimeout(this.aiTimer);
      this.aiTimer = null;
    }
    this.btnPlay.textContent = '▶ Play AI';
    this.btnPlay.classList.remove('active');
    this.setStatus('');
  }

  aiStep() {
    if (!this.aiRunning || this.gameOver) {
      this.stopAI();
      return;
    }

    const t0 = performance.now();
    const move = this.chooseAIMove();
    const elapsed = (performance.now() - t0).toFixed(1);

    if (move) {
      this.makeMove(move.direction);
      this.setStatus(`${DIR_NAMES[move.direction]} — ${elapsed}ms`);
    } else {
      this.stopAI();
      return;
    }

    if (this.aiRunning && !this.gameOver) {
      this.aiTimer = setTimeout(() => this.aiStep(), this.getDelay());
    }
  }

  stepAI() {
    if (this.aiRunning) this.stopAI();
    const player = this.getSelectedPlayer();
    if (player === 'human') {
      this.setStatus('Select an AI player first');
      return;
    }
    if (player === 'tdl' && !tdlNetwork.loaded) {
      this.setStatus('Load weights.bin first');
      return;
    }
    if (this.gameOver) {
      this.setStatus('Game is over — start a new game');
      return;
    }

    const t0 = performance.now();
    const move = this.chooseAIMove();
    const elapsed = (performance.now() - t0).toFixed(1);

    if (move) {
      this.makeMove(move.direction);
      this.setStatus(`Step: ${DIR_NAMES[move.direction]} — ${elapsed}ms`);
    }
  }

  setStatus(msg) {
    this.statusEl.textContent = msg;
  }

  // ── Teacher Mode ──

  toggleTeacher() {
    this.teacherMode = !this.teacherMode;
    this.teachPanel.classList.toggle('visible', this.teacherMode);
    this.btnTeacher.classList.toggle('active', this.teacherMode);
    if (this.teacherMode) {
      this.updateTeacher();
    }
  }

  updateTeacher() {
    if (!this.teacherMode) return;
    const player = this.getSelectedPlayer();

    // Training section is always visible for TDL (even when game over)
    const trainSec = document.getElementById('train-section');
    if (trainSec) {
      trainSec.classList.toggle('visible', player === 'tdl');
    }

    if (this.gameOver) return;
    Teacher.render(this.board, player);
  }

  /** Start training the TDL network from the browser */
  startTraining() {
    if (Trainer.running) return;

    const episodes = parseInt(document.getElementById('train-episodes').value) || 100;
    const alpha = parseFloat(document.getElementById('train-alpha').value) || 0.01;

    const statsEl = document.getElementById('train-stats');
    const pbar = document.getElementById('train-pbar');
    const bpSec = document.getElementById('bp-section');
    const btn = document.getElementById('btn-train');
    btn.textContent = 'Training...';
    btn.disabled = true;

    Trainer.run(
      tdlNetwork,
      episodes,
      alpha,
      // onProgress
      (ep, total, stats, lastResult) => {
        const pct = (ep / total * 100).toFixed(0);
        pbar.style.width = pct + '%';
        const avg = stats.games > 0 ? Math.round(stats.totalScore / stats.games) : 0;

        // Tile distribution
        let tileDist = '';
        const entries = Object.entries(stats.tiles).sort((a,b) => +b[0] - +a[0]);
        for (const [tile, count] of entries.slice(0, 5)) {
          tileDist += `${tile}: ${(count/stats.games*100).toFixed(0)}%  `;
        }

        statsEl.innerHTML =
          `<div class="train-stat"><div class="ts-label">Games</div><div class="ts-value">${stats.games}</div></div>` +
          `<div class="train-stat"><div class="ts-label">Avg Score</div><div class="ts-value">${avg.toLocaleString()}</div></div>` +
          `<div class="train-stat"><div class="ts-label">Best</div><div class="ts-value">${stats.maxScore.toLocaleString()}</div></div>` +
          `<div class="train-stat"><div class="ts-label">Max Tile</div><div class="ts-value">${1 << stats.maxTile}</div></div>`;

        if (tileDist) {
          statsEl.innerHTML += `<div class="train-stat" style="grid-column:1/-1"><div class="ts-label">Max Tile Distribution</div><div class="ts-value" style="font-size:0.7rem">${tileDist}</div></div>`;
        }

        // Render backward pass for last game
        if (lastResult && lastResult.backwardPass.length > 0) {
          bpSec.style.display = '';
          BPViz.render(lastResult.backwardPass);
        }
      },
      // onDone
      (lastResult) => {
        btn.textContent = 'Train';
        btn.disabled = false;
        pbar.style.width = '100%';
        // Refresh teacher view in case TDL is active
        this.updateTeacher();
      }
    );
  }

  /** Stop ongoing training */
  stopTraining() {
    Trainer.stop();
    const btn = document.getElementById('btn-train');
    btn.textContent = 'Train';
    btn.disabled = false;
  }

  /** Reset network weights to zero */
  resetNetwork() {
    tdlNetwork.resetWeights();
    document.getElementById('train-stats').innerHTML = '';
    document.getElementById('bp-section').style.display = 'none';
    document.getElementById('train-pbar').style.width = '0%';
    this.updateTeacher();
  }

  /** Save trained weights to a downloadable weights.bin file */
  saveWeights() {
    const buffer = tdlNetwork.saveToBuffer();
    const blob = new Blob([buffer], { type: 'application/octet-stream' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'weights.bin';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }
}

// ── Start ──
const game = new GameUI();
</script>
</body>
</html>
